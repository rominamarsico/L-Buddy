{
  "Version": 2,
  "Types": [
    {
      "TypeAttribute": {
        "Name": "Observable",
        "Category": "Reactive",
        "Help": "Provides a set of static methods for writing in-memory queries over observable sequences.",
        "ImportedHelp": "<member name=\"T:System.Reactive.Linq.Observable\">\r\n  <summary>\r\n            Provides a set of static methods for writing in-memory queries over observable sequences.\r\n            </summary>\r\n</member>",
        "IsImmutable": true
      },
      "Members": [
        {
          "NodeAttribute": {
            "Name": "Aggregate",
            "Category": "Reactive.Observable",
            "Help": "Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.\n            For aggregation behavior with incremental intermediate results, see Scan.\r\nRemarks: The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.TSource: The type of the elements in the source sequence.\r\nTAccumulate: The type of the result of the aggregation.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Aggregate``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})\">\r\n  <summary>\r\n            Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.\r\n            For aggregation behavior with incremental intermediate results, see <see cref=\"M:System.Reactive.Linq.Observable.Scan``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})\" />.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TAccumulate\">The type of the result of the aggregation.</typeparam>\r\n  <param name=\"source\">An observable sequence to aggregate over.</param>\r\n  <param name=\"seed\">The initial accumulator value.</param>\r\n  <param name=\"accumulator\">An accumulator function to be invoked on each element.</param>\r\n  <returns>An observable sequence containing a single element with the final accumulator value.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"accumulator\" /> is null.</exception>\r\n  <remarks>The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.</remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence to aggregate over.",
                "ImportedHelp": "<param name=\"source\">An observable sequence to aggregate over.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "TAccumulate",
              "PinAttribute": {
                "Help": "The initial accumulator value.",
                "ImportedHelp": "<param name=\"seed\">The initial accumulator value.</param>"
              },
              "DotNetName": "seed"
            },
            {
              "TypeFullName": "System.Func<TAccumulate, TSource, TAccumulate>",
              "PinAttribute": {
                "Help": "An accumulator function to be invoked on each element.",
                "ImportedHelp": "<param name=\"accumulator\">An accumulator function to be invoked on each element.</param>"
              },
              "DotNetName": "accumulator"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TAccumulate>",
            "PinAttribute": {
              "Help": "An observable sequence containing a single element with the final accumulator value.",
              "ImportedHelp": "<returns>An observable sequence containing a single element with the final accumulator value.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Aggregate"
        },
        {
          "NodeAttribute": {
            "Name": "Aggregate",
            "Version": "Selector",
            "Category": "Reactive.Observable",
            "Help": "Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value,\n            and the specified result selector function is used to select the result value.\r\nRemarks: The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.TSource: The type of the elements in the source sequence.\r\nTAccumulate: The type of the accumulator value.\r\nTResult: The type of the resulting value.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Aggregate``3(System.IObservable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})\">\r\n  <summary>\r\n            Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value,\r\n            and the specified result selector function is used to select the result value.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TAccumulate\">The type of the accumulator value.</typeparam>\r\n  <typeparam name=\"TResult\">The type of the resulting value.</typeparam>\r\n  <param name=\"source\">An observable sequence to aggregate over.</param>\r\n  <param name=\"seed\">The initial accumulator value.</param>\r\n  <param name=\"accumulator\">An accumulator function to be invoked on each element.</param>\r\n  <param name=\"resultSelector\">A function to transform the final accumulator value into the result value.</param>\r\n  <returns>An observable sequence containing a single element with the final accumulator value.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"accumulator\" /> or <paramref name=\"resultSelector\" /> is null.</exception>\r\n  <remarks>The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.</remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence to aggregate over.",
                "ImportedHelp": "<param name=\"source\">An observable sequence to aggregate over.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "TAccumulate",
              "PinAttribute": {
                "Help": "The initial accumulator value.",
                "ImportedHelp": "<param name=\"seed\">The initial accumulator value.</param>"
              },
              "DotNetName": "seed"
            },
            {
              "TypeFullName": "System.Func<TAccumulate, TSource, TAccumulate>",
              "PinAttribute": {
                "Help": "An accumulator function to be invoked on each element.",
                "ImportedHelp": "<param name=\"accumulator\">An accumulator function to be invoked on each element.</param>"
              },
              "DotNetName": "accumulator"
            },
            {
              "TypeFullName": "System.Func<TAccumulate, TResult>",
              "PinAttribute": {
                "Help": "A function to transform the final accumulator value into the result value.",
                "ImportedHelp": "<param name=\"resultSelector\">A function to transform the final accumulator value into the result value.</param>"
              },
              "DotNetName": "resultSelector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "An observable sequence containing a single element with the final accumulator value.",
              "ImportedHelp": "<returns>An observable sequence containing a single element with the final accumulator value.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Aggregate"
        },
        {
          "NodeAttribute": {
            "Name": "All",
            "Category": "Reactive.Observable",
            "Help": "Determines whether all elements of an observable sequence satisfy a condition.\r\nRemarks: The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.All``1(System.IObservable{``0},System.Func{``0,System.Boolean})\">\r\n  <summary>\r\n            Determines whether all elements of an observable sequence satisfy a condition.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence whose elements to apply the predicate to.</param>\r\n  <param name=\"predicate\">A function to test each element for a condition.</param>\r\n  <returns>An observable sequence containing a single element determining whether all elements in the source sequence pass the test in the specified predicate.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"predicate\" /> is null.</exception>\r\n  <remarks>The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.</remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence whose elements to apply the predicate to.",
                "ImportedHelp": "<param name=\"source\">An observable sequence whose elements to apply the predicate to.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, System.Boolean>",
              "PinAttribute": {
                "Help": "A function to test each element for a condition.",
                "ImportedHelp": "<param name=\"predicate\">A function to test each element for a condition.</param>"
              },
              "DotNetName": "predicate"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Boolean>",
            "PinAttribute": {
              "Help": "An observable sequence containing a single element determining whether all elements in the source sequence pass the test in the specified predicate.",
              "ImportedHelp": "<returns>An observable sequence containing a single element determining whether all elements in the source sequence pass the test in the specified predicate.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "All"
        },
        {
          "NodeAttribute": {
            "Name": "Amb",
            "Category": "Reactive.Observable",
            "Help": "Propagates the observable sequence that reacts first.TSource: The type of the elements in the source sequences.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Amb``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})\">\r\n  <summary>\r\n            Propagates the observable sequence that reacts first.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequences.</typeparam>\r\n  <param name=\"sources\">Observable sources competing to react first.</param>\r\n  <returns>An observable sequence that surfaces any of the given sequences, whichever reacted first.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"sources\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Collections.Generic.IEnumerable<System.IObservable<TSource>>",
              "PinAttribute": {
                "Help": "Observable sources competing to react first.",
                "ImportedHelp": "<param name=\"sources\">Observable sources competing to react first.</param>"
              },
              "DotNetName": "sources"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence that surfaces any of the given sequences, whichever reacted first.",
              "ImportedHelp": "<returns>An observable sequence that surfaces any of the given sequences, whichever reacted first.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Amb"
        },
        {
          "NodeAttribute": {
            "Name": "Amb",
            "Version": "IObservable<TSource> IObservable<TSource>",
            "Category": "Reactive.Observable",
            "Help": "Propagates the observable sequence that reacts first.TSource: The type of the elements in the source sequences.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})\">\r\n  <summary>\r\n            Propagates the observable sequence that reacts first.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequences.</typeparam>\r\n  <param name=\"first\">First observable sequence.</param>\r\n  <param name=\"second\">Second observable sequence.</param>\r\n  <returns>An observable sequence that surfaces either of the given sequences, whichever reacted first.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"first\" /> or <paramref name=\"second\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "First observable sequence.",
                "ImportedHelp": "<param name=\"first\">First observable sequence.</param>"
              },
              "DotNetName": "first"
            },
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Second observable sequence.",
                "ImportedHelp": "<param name=\"second\">Second observable sequence.</param>"
              },
              "DotNetName": "second"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence that surfaces either of the given sequences, whichever reacted first.",
              "ImportedHelp": "<returns>An observable sequence that surfaces either of the given sequences, whichever reacted first.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Amb"
        },
        {
          "NodeAttribute": {
            "Name": "And",
            "Category": "Reactive.Observable",
            "Help": "Creates a pattern that matches when both observable sequences have an available element.TLeft: The type of the elements in the left sequence.\r\nTRight: The type of the elements in the right sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.And``2(System.IObservable{``0},System.IObservable{``1})\">\r\n  <summary>\r\n            Creates a pattern that matches when both observable sequences have an available element.\r\n            </summary>\r\n  <typeparam name=\"TLeft\">The type of the elements in the left sequence.</typeparam>\r\n  <typeparam name=\"TRight\">The type of the elements in the right sequence.</typeparam>\r\n  <param name=\"left\">Observable sequence to match with the right sequence.</param>\r\n  <param name=\"right\">Observable sequence to match with the left sequence.</param>\r\n  <returns>Pattern object that matches when both observable sequences have an available element.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"left\" /> or <paramref name=\"right\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TLeft>",
              "PinAttribute": {
                "Help": "Observable sequence to match with the right sequence.",
                "ImportedHelp": "<param name=\"left\">Observable sequence to match with the right sequence.</param>"
              },
              "DotNetName": "left"
            },
            {
              "TypeFullName": "System.IObservable<TRight>",
              "PinAttribute": {
                "Help": "Observable sequence to match with the left sequence.",
                "ImportedHelp": "<param name=\"right\">Observable sequence to match with the left sequence.</param>"
              },
              "DotNetName": "right"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Pattern<TLeft, TRight>",
            "PinAttribute": {
              "Help": "Pattern object that matches when both observable sequences have an available element.",
              "ImportedHelp": "<returns>Pattern object that matches when both observable sequences have an available element.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "And"
        },
        {
          "NodeAttribute": {
            "Name": "Any",
            "Category": "Reactive.Observable",
            "Help": "Determines whether an observable sequence contains any elements.\r\nRemarks: The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Any``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Determines whether an observable sequence contains any elements.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence to check for non-emptiness.</param>\r\n  <returns>An observable sequence containing a single element determining whether the source sequence contains any elements.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <remarks>The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.</remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence to check for non-emptiness.",
                "ImportedHelp": "<param name=\"source\">An observable sequence to check for non-emptiness.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Boolean>",
            "PinAttribute": {
              "Help": "An observable sequence containing a single element determining whether the source sequence contains any elements.",
              "ImportedHelp": "<returns>An observable sequence containing a single element determining whether the source sequence contains any elements.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Any"
        },
        {
          "NodeAttribute": {
            "Name": "Any",
            "Version": "Predicate",
            "Category": "Reactive.Observable",
            "Help": "Determines whether any element of an observable sequence satisfies a condition.\r\nRemarks: The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Any``1(System.IObservable{``0},System.Func{``0,System.Boolean})\">\r\n  <summary>\r\n            Determines whether any element of an observable sequence satisfies a condition.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence whose elements to apply the predicate to.</param>\r\n  <param name=\"predicate\">A function to test each element for a condition.</param>\r\n  <returns>An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"predicate\" /> is null.</exception>\r\n  <remarks>The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.</remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence whose elements to apply the predicate to.",
                "ImportedHelp": "<param name=\"source\">An observable sequence whose elements to apply the predicate to.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, System.Boolean>",
              "PinAttribute": {
                "Help": "A function to test each element for a condition.",
                "ImportedHelp": "<param name=\"predicate\">A function to test each element for a condition.</param>"
              },
              "DotNetName": "predicate"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Boolean>",
            "PinAttribute": {
              "Help": "An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate.",
              "ImportedHelp": "<returns>An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Any"
        },
        {
          "NodeAttribute": {
            "Name": "Buffer",
            "Category": "Reactive.Observable",
            "Help": "Projects each element of an observable sequence into consecutive non-overlapping buffers which are produced based on element count information.TSource: The type of the elements in the source sequence, and in the lists in the result sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.Int32)\">\r\n  <summary>\r\n            Projects each element of an observable sequence into consecutive non-overlapping buffers which are produced based on element count information.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence, and in the lists in the result sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to produce buffers over.</param>\r\n  <param name=\"count\">Length of each buffer.</param>\r\n  <returns>An observable sequence of buffers.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"count\" /> is less than or equal to zero.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to produce buffers over.",
                "ImportedHelp": "<param name=\"source\">Source sequence to produce buffers over.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Int32",
              "PinAttribute": {
                "Help": "Length of each buffer.",
                "ImportedHelp": "<param name=\"count\">Length of each buffer.</param>"
              },
              "DotNetName": "count"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Collections.Generic.IList<TSource>>",
            "PinAttribute": {
              "Help": "An observable sequence of buffers.",
              "ImportedHelp": "<returns>An observable sequence of buffers.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Buffer"
        },
        {
          "NodeAttribute": {
            "Name": "Buffer",
            "Version": "Duration",
            "Category": "Reactive.Observable",
            "Help": "Projects each element of an observable sequence into consecutive non-overlapping buffers which are produced based on timing information.\r\nRemarks: Specifying a TimeSpan.Zero value for Time Span is not recommended but supported, causing the scheduler to create buffers as fast as it can.\n            Because all source sequence elements end up in one of the buffers, some buffers won't have a zero time span. This is a side-effect of the asynchrony introduced\n            by the scheduler, where the action to close the current buffer and to create a new buffer may not execute immediately, despite the TimeSpan.Zero due time.TSource: The type of the elements in the source sequence, and in the lists in the result sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan)\">\r\n  <summary>\r\n            Projects each element of an observable sequence into consecutive non-overlapping buffers which are produced based on timing information.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence, and in the lists in the result sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to produce buffers over.</param>\r\n  <param name=\"timeSpan\">Length of each buffer.</param>\r\n  <returns>An observable sequence of buffers.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"timeSpan\" /> is less than TimeSpan.Zero.</exception>\r\n  <remarks>\r\n            Specifying a TimeSpan.Zero value for <paramref name=\"timeSpan\" /> is not recommended but supported, causing the scheduler to create buffers as fast as it can.\r\n            Because all source sequence elements end up in one of the buffers, some buffers won't have a zero time span. This is a side-effect of the asynchrony introduced\r\n            by the scheduler, where the action to close the current buffer and to create a new buffer may not execute immediately, despite the TimeSpan.Zero due time.\r\n            </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to produce buffers over.",
                "ImportedHelp": "<param name=\"source\">Source sequence to produce buffers over.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Length of each buffer.",
                "ImportedHelp": "<param name=\"timeSpan\">Length of each buffer.</param>"
              },
              "DotNetName": "timeSpan"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Collections.Generic.IList<TSource>>",
            "PinAttribute": {
              "Help": "An observable sequence of buffers.",
              "ImportedHelp": "<returns>An observable sequence of buffers.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Buffer"
        },
        {
          "NodeAttribute": {
            "Name": "Buffer",
            "Version": "Skip",
            "Category": "Reactive.Observable",
            "Help": "Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.TSource: The type of the elements in the source sequence, and in the lists in the result sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.Int32,System.Int32)\">\r\n  <summary>\r\n            Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence, and in the lists in the result sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to produce buffers over.</param>\r\n  <param name=\"count\">Length of each buffer.</param>\r\n  <param name=\"skip\">Number of elements to skip between creation of consecutive buffers.</param>\r\n  <returns>An observable sequence of buffers.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"count\" /> or <paramref name=\"skip\" /> is less than or equal to zero.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to produce buffers over.",
                "ImportedHelp": "<param name=\"source\">Source sequence to produce buffers over.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Int32",
              "PinAttribute": {
                "Help": "Length of each buffer.",
                "ImportedHelp": "<param name=\"count\">Length of each buffer.</param>"
              },
              "DotNetName": "count"
            },
            {
              "TypeFullName": "System.Int32",
              "PinAttribute": {
                "Help": "Number of elements to skip between creation of consecutive buffers.",
                "ImportedHelp": "<param name=\"skip\">Number of elements to skip between creation of consecutive buffers.</param>"
              },
              "DotNetName": "skip"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Collections.Generic.IList<TSource>>",
            "PinAttribute": {
              "Help": "An observable sequence of buffers.",
              "ImportedHelp": "<returns>An observable sequence of buffers.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Buffer"
        },
        {
          "NodeAttribute": {
            "Name": "Buffer",
            "Version": "Skip Duration",
            "Category": "Reactive.Observable",
            "Help": "Projects each element of an observable sequence into zero or more buffers which are produced based on timing information.\r\nRemarks: Specifying a TimeSpan.Zero value for Time Span is not recommended but supported, causing the scheduler to create buffers with minimum duration\n            length. However, some buffers won't have a zero time span. This is a side-effect of the asynchrony introduced by the scheduler, where the action to close the\n            current buffer may not execute immediately, despite the TimeSpan.Zero due time.Specifying a TimeSpan.Zero value for Time Shift is not recommended but supported, causing the scheduler to create buffers as fast as it can.\n            However, this doesn't mean all buffers will start at the beginning of the source sequence. This is a side-effect of the asynchrony introduced by the scheduler,\n            where the action to create a new buffer may not execute immediately, despite the TimeSpan.Zero due time.TSource: The type of the elements in the source sequence, and in the lists in the result sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan,System.TimeSpan)\">\r\n  <summary>\r\n            Projects each element of an observable sequence into zero or more buffers which are produced based on timing information.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence, and in the lists in the result sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to produce buffers over.</param>\r\n  <param name=\"timeSpan\">Length of each buffer.</param>\r\n  <param name=\"timeShift\">Interval between creation of consecutive buffers.</param>\r\n  <returns>An observable sequence of buffers.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"timeSpan\" /> or <paramref name=\"timeSpan\" /> is less than TimeSpan.Zero.</exception>\r\n  <remarks>\r\n    <para>\r\n            Specifying a TimeSpan.Zero value for <paramref name=\"timeSpan\" /> is not recommended but supported, causing the scheduler to create buffers with minimum duration\r\n            length. However, some buffers won't have a zero time span. This is a side-effect of the asynchrony introduced by the scheduler, where the action to close the\r\n            current buffer may not execute immediately, despite the TimeSpan.Zero due time.\r\n            </para>\r\n    <para>\r\n            Specifying a TimeSpan.Zero value for <paramref name=\"timeShift\" /> is not recommended but supported, causing the scheduler to create buffers as fast as it can.\r\n            However, this doesn't mean all buffers will start at the beginning of the source sequence. This is a side-effect of the asynchrony introduced by the scheduler,\r\n            where the action to create a new buffer may not execute immediately, despite the TimeSpan.Zero due time.\r\n            </para>\r\n  </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to produce buffers over.",
                "ImportedHelp": "<param name=\"source\">Source sequence to produce buffers over.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Length of each buffer.",
                "ImportedHelp": "<param name=\"timeSpan\">Length of each buffer.</param>"
              },
              "DotNetName": "timeSpan"
            },
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Interval between creation of consecutive buffers.",
                "ImportedHelp": "<param name=\"timeShift\">Interval between creation of consecutive buffers.</param>"
              },
              "DotNetName": "timeShift"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Collections.Generic.IList<TSource>>",
            "PinAttribute": {
              "Help": "An observable sequence of buffers.",
              "ImportedHelp": "<returns>An observable sequence of buffers.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Buffer"
        },
        {
          "NodeAttribute": {
            "Name": "Chunkify",
            "Category": "Reactive.Observable",
            "Help": "Produces an enumerable sequence of consecutive (possibly empty) chunks of the source sequence.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Chunkify``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Produces an enumerable sequence of consecutive (possibly empty) chunks of the source sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source observable sequence.</param>\r\n  <returns>The enumerable sequence that returns consecutive (possibly empty) chunks upon each iteration.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source observable sequence.",
                "ImportedHelp": "<param name=\"source\">Source observable sequence.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Collections.Generic.IEnumerable<System.Collections.Generic.IList<TSource>>",
            "PinAttribute": {
              "Help": "The enumerable sequence that returns consecutive (possibly empty) chunks upon each iteration.",
              "ImportedHelp": "<returns>The enumerable sequence that returns consecutive (possibly empty) chunks upon each iteration.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Chunkify"
        },
        {
          "NodeAttribute": {
            "Name": "CombineLatest",
            "Category": "Reactive.Observable",
            "Help": "Merges two observable sequences into one observable sequence by using the selector function whenever one of the observable sequences produces an element.TSource1: The type of the elements in the first source sequence.\r\nTSource2: The type of the elements in the second source sequence.\r\nTResult: The type of the elements in the result sequence, returned by the selector function.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.CombineLatest``3(System.IObservable{``0},System.IObservable{``1},System.Func{``0,``1,``2})\">\r\n  <summary>\r\n            Merges two observable sequences into one observable sequence by using the selector function whenever one of the observable sequences produces an element.\r\n            </summary>\r\n  <typeparam name=\"TSource1\">The type of the elements in the first source sequence.</typeparam>\r\n  <typeparam name=\"TSource2\">The type of the elements in the second source sequence.</typeparam>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence, returned by the selector function.</typeparam>\r\n  <param name=\"first\">First observable source.</param>\r\n  <param name=\"second\">Second observable source.</param>\r\n  <param name=\"resultSelector\">Function to invoke whenever either of the sources produces an element.</param>\r\n  <returns>An observable sequence containing the result of combining elements of both sources using the specified result selector function.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"first\" /> or <paramref name=\"second\" /> or <paramref name=\"resultSelector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource1>",
              "PinAttribute": {
                "Help": "First observable source.",
                "ImportedHelp": "<param name=\"first\">First observable source.</param>"
              },
              "DotNetName": "first"
            },
            {
              "TypeFullName": "System.IObservable<TSource2>",
              "PinAttribute": {
                "Help": "Second observable source.",
                "ImportedHelp": "<param name=\"second\">Second observable source.</param>"
              },
              "DotNetName": "second"
            },
            {
              "TypeFullName": "System.Func<TSource1, TSource2, TResult>",
              "PinAttribute": {
                "Help": "Function to invoke whenever either of the sources produces an element.",
                "ImportedHelp": "<param name=\"resultSelector\">Function to invoke whenever either of the sources produces an element.</param>"
              },
              "DotNetName": "resultSelector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "An observable sequence containing the result of combining elements of both sources using the specified result selector function.",
              "ImportedHelp": "<returns>An observable sequence containing the result of combining elements of both sources using the specified result selector function.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "CombineLatest"
        },
        {
          "NodeAttribute": {
            "Name": "Concat",
            "Category": "Reactive.Observable",
            "Help": "Concatenates the second observable sequence to the first observable sequence upon successful termination of the first.TSource: The type of the elements in the source sequences.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Concat``1(System.IObservable{``0},System.IObservable{``0})\">\r\n  <summary>\r\n            Concatenates the second observable sequence to the first observable sequence upon successful termination of the first.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequences.</typeparam>\r\n  <param name=\"first\">First observable sequence.</param>\r\n  <param name=\"second\">Second observable sequence.</param>\r\n  <returns>An observable sequence that contains the elements of the first sequence, followed by those of the second the sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"first\" /> or <paramref name=\"second\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "First observable sequence.",
                "ImportedHelp": "<param name=\"first\">First observable sequence.</param>"
              },
              "DotNetName": "first"
            },
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Name": "Input 2",
                "Help": "Second observable sequence.",
                "ImportedHelp": "<param name=\"second\">Second observable sequence.</param>"
              },
              "DotNetName": "second"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence that contains the elements of the first sequence, followed by those of the second the sequence.",
              "ImportedHelp": "<returns>An observable sequence that contains the elements of the first sequence, followed by those of the second the sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Concat"
        },
        {
          "NodeAttribute": {
            "Name": "Contains",
            "Category": "Reactive.Observable",
            "Help": "Determines whether an observable sequence contains a specified element by using the default equality comparer.\r\nRemarks: The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Contains``1(System.IObservable{``0},``0)\">\r\n  <summary>\r\n            Determines whether an observable sequence contains a specified element by using the default equality comparer.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence in which to locate a value.</param>\r\n  <param name=\"value\">The value to locate in the source sequence.</param>\r\n  <returns>An observable sequence containing a single element determining whether the source sequence contains an element that has the specified value.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <remarks>The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.</remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence in which to locate a value.",
                "ImportedHelp": "<param name=\"source\">An observable sequence in which to locate a value.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "TSource",
              "PinAttribute": {
                "Help": "The value to locate in the source sequence.",
                "ImportedHelp": "<param name=\"value\">The value to locate in the source sequence.</param>"
              },
              "DotNetName": "value"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Boolean>",
            "PinAttribute": {
              "Help": "An observable sequence containing a single element determining whether the source sequence contains an element that has the specified value.",
              "ImportedHelp": "<returns>An observable sequence containing a single element determining whether the source sequence contains an element that has the specified value.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Contains"
        },
        {
          "NodeAttribute": {
            "Name": "Count",
            "Category": "Reactive.Observable",
            "Help": "Returns an observable sequence containing an T:System.Int32 that represents the total number of elements in an observable sequence.\r\nRemarks: The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Count``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Returns an observable sequence containing an <see cref=\"T:System.Int32\" /> that represents the total number of elements in an observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence that contains elements to be counted.</param>\r\n  <returns>An observable sequence containing a single element with the number of elements in the input sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.OverflowException\">(Asynchronous) The number of elements in the source sequence is larger than <see cref=\"M:System.Int64.MaxValue\" />.</exception>\r\n  <remarks>The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.</remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence that contains elements to be counted.",
                "ImportedHelp": "<param name=\"source\">An observable sequence that contains elements to be counted.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Int32>",
            "PinAttribute": {
              "Help": "An observable sequence containing a single element with the number of elements in the input sequence.",
              "ImportedHelp": "<returns>An observable sequence containing a single element with the number of elements in the input sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Count"
        },
        {
          "NodeAttribute": {
            "Name": "Count",
            "Version": "Predicate",
            "Category": "Reactive.Observable",
            "Help": "Returns an observable sequence containing an T:System.Int32 that represents how many elements in the specified observable sequence satisfy a condition.\r\nRemarks: The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Count``1(System.IObservable{``0},System.Func{``0,System.Boolean})\">\r\n  <summary>\r\n            Returns an observable sequence containing an <see cref=\"T:System.Int32\" /> that represents how many elements in the specified observable sequence satisfy a condition.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence that contains elements to be counted.</param>\r\n  <param name=\"predicate\">A function to test each element for a condition.</param>\r\n  <returns>An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"predicate\" /> is null.</exception>\r\n  <remarks>The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.</remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence that contains elements to be counted.",
                "ImportedHelp": "<param name=\"source\">An observable sequence that contains elements to be counted.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, System.Boolean>",
              "PinAttribute": {
                "Help": "A function to test each element for a condition.",
                "ImportedHelp": "<param name=\"predicate\">A function to test each element for a condition.</param>"
              },
              "DotNetName": "predicate"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Int32>",
            "PinAttribute": {
              "Help": "An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function.",
              "ImportedHelp": "<returns>An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Count"
        },
        {
          "NodeAttribute": {
            "Name": "Create",
            "Category": "Reactive.Observable",
            "Help": "Creates an observable sequence from a specified Subscribe method implementation.\r\nRemarks: Use of this operator is preferred over manual implementation of the IObservable<T> interface. In case\n            you need a type implementing IObservable<T> rather than an anonymous implementation, consider using\n            the T:System.Reactive.ObservableBase`1 abstract base class.TResult: The type of the elements in the produced sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.IDisposable})\">\r\n  <summary>\r\n            Creates an observable sequence from a specified Subscribe method implementation.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the elements in the produced sequence.</typeparam>\r\n  <param name=\"subscribe\">Implementation of the resulting observable sequence's Subscribe method.</param>\r\n  <returns>The observable sequence with the specified implementation for the Subscribe method.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"subscribe\" /> is null.</exception>\r\n  <remarks>\r\n            Use of this operator is preferred over manual implementation of the IObservable&lt;T&gt; interface. In case\r\n            you need a type implementing IObservable&lt;T&gt; rather than an anonymous implementation, consider using\r\n            the <see cref=\"T:System.Reactive.ObservableBase`1\" /> abstract base class.\r\n            </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<System.IObserver<TResult>, System.IDisposable>",
              "PinAttribute": {
                "Help": "Implementation of the resulting observable sequence's Subscribe method.",
                "ImportedHelp": "<param name=\"subscribe\">Implementation of the resulting observable sequence's Subscribe method.</param>"
              },
              "DotNetName": "subscribe"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "The observable sequence with the specified implementation for the Subscribe method.",
              "ImportedHelp": "<returns>The observable sequence with the specified implementation for the Subscribe method.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Create"
        },
        {
          "NodeAttribute": {
            "Name": "Create",
            "Version": "Action",
            "Category": "Reactive.Observable",
            "Help": "Creates an observable sequence from a specified Subscribe method implementation.\r\nRemarks: Use of this operator is preferred over manual implementation of the IObservable<T> interface. In case\n            you need a type implementing IObservable<T> rather than an anonymous implementation, consider using\n            the T:System.Reactive.ObservableBase`1 abstract base class.TResult: The type of the elements in the produced sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Action})\">\r\n  <summary>\r\n            Creates an observable sequence from a specified Subscribe method implementation.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the elements in the produced sequence.</typeparam>\r\n  <param name=\"subscribe\">Implementation of the resulting observable sequence's Subscribe method, returning an Action delegate that will be wrapped in an IDisposable.</param>\r\n  <returns>The observable sequence with the specified implementation for the Subscribe method.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"subscribe\" /> is null.</exception>\r\n  <remarks>\r\n            Use of this operator is preferred over manual implementation of the IObservable&lt;T&gt; interface. In case\r\n            you need a type implementing IObservable&lt;T&gt; rather than an anonymous implementation, consider using\r\n            the <see cref=\"T:System.Reactive.ObservableBase`1\" /> abstract base class.\r\n            </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<System.IObserver<TResult>, System.Action>",
              "PinAttribute": {
                "Help": "Implementation of the resulting observable sequence's Subscribe method, returning an Action delegate that will be wrapped in an IDisposable.",
                "ImportedHelp": "<param name=\"subscribe\">Implementation of the resulting observable sequence's Subscribe method, returning an Action delegate that will be wrapped in an IDisposable.</param>"
              },
              "DotNetName": "subscribe"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "The observable sequence with the specified implementation for the Subscribe method.",
              "ImportedHelp": "<returns>The observable sequence with the specified implementation for the Subscribe method.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Create"
        },
        {
          "NodeAttribute": {
            "Name": "Delay",
            "Category": "Reactive.Observable",
            "Help": "Time shifts the observable sequence by the specified relative time duration.\n            The relative time intervals between the values are preserved.\r\nRemarks: This operator is less efficient than DelaySubscription because it records all notifications and time-delays those. This allows for immediate propagation of errors.Observer callbacks for the resulting sequence will be run on the default scheduler. This effect is similar to using ObserveOn.Exceptions signaled by the source sequence through an OnError callback are forwarded immediately to the result sequence. Any OnNext notifications that were in the queue at the point of the OnError callback will be dropped.\n            In order to delay error propagation, consider using the M:System.Reactive.Linq.Observable.Materialize``1(System.IObservable{``0}) and M:System.Reactive.Linq.Observable.Dematerialize``1(System.IObservable{System.Reactive.Notification{``0}}) operators, or use DelaySubscription.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.TimeSpan)\">\r\n  <summary>\r\n            Time shifts the observable sequence by the specified relative time duration.\r\n            The relative time intervals between the values are preserved.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to delay values for.</param>\r\n  <param name=\"dueTime\">Relative time by which to shift the observable sequence. If this value is equal to TimeSpan.Zero, the scheduler will dispatch observer callbacks as soon as possible.</param>\r\n  <returns>Time-shifted sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"dueTime\" /> is less than TimeSpan.Zero.</exception>\r\n  <remarks>\r\n    <para>\r\n            This operator is less efficient than <see cref=\"M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan)\">DelaySubscription</see> because it records all notifications and time-delays those. This allows for immediate propagation of errors.\r\n            </para>\r\n    <para>\r\n            Observer callbacks for the resulting sequence will be run on the default scheduler. This effect is similar to using ObserveOn.\r\n            </para>\r\n    <para>\r\n            Exceptions signaled by the source sequence through an OnError callback are forwarded immediately to the result sequence. Any OnNext notifications that were in the queue at the point of the OnError callback will be dropped.\r\n            In order to delay error propagation, consider using the <see cref=\"M:System.Reactive.Linq.Observable.Materialize``1(System.IObservable{``0})\">Observable.Materialize</see> and <see cref=\"M:System.Reactive.Linq.Observable.Dematerialize``1(System.IObservable{System.Reactive.Notification{``0}})\">Observable.Dematerialize</see> operators, or use <see cref=\"M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan)\">DelaySubscription</see>.\r\n            </para>\r\n  </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to delay values for.",
                "ImportedHelp": "<param name=\"source\">Source sequence to delay values for.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Relative time by which to shift the observable sequence. If this value is equal to TimeSpan.Zero, the scheduler will dispatch observer callbacks as soon as possible.",
                "ImportedHelp": "<param name=\"dueTime\">Relative time by which to shift the observable sequence. If this value is equal to TimeSpan.Zero, the scheduler will dispatch observer callbacks as soon as possible.</param>"
              },
              "DotNetName": "dueTime"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "Time-shifted sequence.",
              "ImportedHelp": "<returns>Time-shifted sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Delay"
        },
        {
          "NodeAttribute": {
            "Name": "Delay",
            "Version": "Selector",
            "Category": "Reactive.Observable",
            "Help": "Time shifts the observable sequence based on a delay selector function for each element.TSource: The type of the elements in the source sequence.\r\nTDelay: The type of the elements in the delay sequences used to denote the delay duration of each element in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Delay``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})\">\r\n  <summary>\r\n            Time shifts the observable sequence based on a delay selector function for each element.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TDelay\">The type of the elements in the delay sequences used to denote the delay duration of each element in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to delay values for.</param>\r\n  <param name=\"delayDurationSelector\">Selector function to retrieve a sequence indicating the delay for each given element.</param>\r\n  <returns>Time-shifted sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"delayDurationSelector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to delay values for.",
                "ImportedHelp": "<param name=\"source\">Source sequence to delay values for.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, System.IObservable<TDelay>>",
              "PinAttribute": {
                "Help": "Selector function to retrieve a sequence indicating the delay for each given element.",
                "ImportedHelp": "<param name=\"delayDurationSelector\">Selector function to retrieve a sequence indicating the delay for each given element.</param>"
              },
              "DotNetName": "delayDurationSelector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "Time-shifted sequence.",
              "ImportedHelp": "<returns>Time-shifted sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Delay"
        },
        {
          "NodeAttribute": {
            "Name": "DelaySubscription",
            "Category": "Reactive.Observable",
            "Help": "Time shifts the observable sequence by delaying the subscription with the specified relative time duration.\r\nRemarks: This operator is more efficient than Delay but postpones all side-effects of subscription and affects error propagation timing.The side-effects of subscribing to the source sequence will be run on the default scheduler. Observer callbacks will not be affected.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan)\">\r\n  <summary>\r\n            Time shifts the observable sequence by delaying the subscription with the specified relative time duration.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to delay subscription for.</param>\r\n  <param name=\"dueTime\">Relative time shift of the subscription.</param>\r\n  <returns>Time-shifted sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"dueTime\" /> is less than TimeSpan.Zero.</exception>\r\n  <remarks>\r\n    <para>\r\n            This operator is more efficient than <see cref=\"M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.TimeSpan)\">Delay</see> but postpones all side-effects of subscription and affects error propagation timing.\r\n            </para>\r\n    <para>\r\n            The side-effects of subscribing to the source sequence will be run on the default scheduler. Observer callbacks will not be affected.\r\n            </para>\r\n  </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to delay subscription for.",
                "ImportedHelp": "<param name=\"source\">Source sequence to delay subscription for.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Relative time shift of the subscription.",
                "ImportedHelp": "<param name=\"dueTime\">Relative time shift of the subscription.</param>"
              },
              "DotNetName": "dueTime"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "Time-shifted sequence.",
              "ImportedHelp": "<returns>Time-shifted sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "DelaySubscription"
        },
        {
          "NodeAttribute": {
            "Name": "Distinct",
            "Category": "Reactive.Observable",
            "Help": "Returns an observable sequence that contains only distinct elements.\r\nRemarks: Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Distinct``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Returns an observable sequence that contains only distinct elements.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence to retain distinct elements for.</param>\r\n  <returns>An observable sequence only containing the distinct elements from the source sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <remarks>Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.</remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence to retain distinct elements for.",
                "ImportedHelp": "<param name=\"source\">An observable sequence to retain distinct elements for.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence only containing the distinct elements from the source sequence.",
              "ImportedHelp": "<returns>An observable sequence only containing the distinct elements from the source sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Distinct"
        },
        {
          "NodeAttribute": {
            "Name": "Distinct",
            "Version": "Selector",
            "Category": "Reactive.Observable",
            "Help": "Returns an observable sequence that contains only distinct elements according to the keySelector.\r\nRemarks: Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.TSource: The type of the elements in the source sequence.\r\nTKey: The type of the discriminator key computed for each element in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Distinct``2(System.IObservable{``0},System.Func{``0,``1})\">\r\n  <summary>\r\n            Returns an observable sequence that contains only distinct elements according to the keySelector.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TKey\">The type of the discriminator key computed for each element in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence to retain distinct elements for.</param>\r\n  <param name=\"keySelector\">A function to compute the comparison key for each element.</param>\r\n  <returns>An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"keySelector\" /> is null.</exception>\r\n  <remarks>Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.</remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence to retain distinct elements for.",
                "ImportedHelp": "<param name=\"source\">An observable sequence to retain distinct elements for.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, TKey>",
              "PinAttribute": {
                "Help": "A function to compute the comparison key for each element.",
                "ImportedHelp": "<param name=\"keySelector\">A function to compute the comparison key for each element.</param>"
              },
              "DotNetName": "keySelector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.",
              "ImportedHelp": "<returns>An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Distinct"
        },
        {
          "NodeAttribute": {
            "Name": "DistinctUntilChanged",
            "Category": "Reactive.Observable",
            "Help": "Returns an observable sequence that contains only distinct contiguous elements.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.DistinctUntilChanged``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Returns an observable sequence that contains only distinct contiguous elements.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence to retain distinct contiguous elements for.</param>\r\n  <returns>An observable sequence only containing the distinct contiguous elements from the source sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence to retain distinct contiguous elements for.",
                "ImportedHelp": "<param name=\"source\">An observable sequence to retain distinct contiguous elements for.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence only containing the distinct contiguous elements from the source sequence.",
              "ImportedHelp": "<returns>An observable sequence only containing the distinct contiguous elements from the source sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "DistinctUntilChanged"
        },
        {
          "NodeAttribute": {
            "Name": "DistinctUntilChanged",
            "Version": "Selector",
            "Category": "Reactive.Observable",
            "Help": "Returns an observable sequence that contains only distinct contiguous elements according to the keySelector.TSource: The type of the elements in the source sequence.\r\nTKey: The type of the discriminator key computed for each element in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.DistinctUntilChanged``2(System.IObservable{``0},System.Func{``0,``1})\">\r\n  <summary>\r\n            Returns an observable sequence that contains only distinct contiguous elements according to the keySelector.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TKey\">The type of the discriminator key computed for each element in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence to retain distinct contiguous elements for, based on a computed key value.</param>\r\n  <param name=\"keySelector\">A function to compute the comparison key for each element.</param>\r\n  <returns>An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"keySelector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence to retain distinct contiguous elements for, based on a computed key value.",
                "ImportedHelp": "<param name=\"source\">An observable sequence to retain distinct contiguous elements for, based on a computed key value.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, TKey>",
              "PinAttribute": {
                "Help": "A function to compute the comparison key for each element.",
                "ImportedHelp": "<param name=\"keySelector\">A function to compute the comparison key for each element.</param>"
              },
              "DotNetName": "keySelector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.",
              "ImportedHelp": "<returns>An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "DistinctUntilChanged"
        },
        {
          "NodeAttribute": {
            "Name": "Do",
            "Category": "System.Reactive.Linq",
            "Help": "Invokes an action for each element in the observable sequence, and propagates all observer messages through the result sequence.\n            This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Do``1(System.IObservable{``0},System.Action{``0})\">\r\n  <summary>\r\n            Invokes an action for each element in the observable sequence, and propagates all observer messages through the result sequence.\r\n            This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence.</param>\r\n  <param name=\"onNext\">Action to invoke for each element in the observable sequence.</param>\r\n  <returns>The source sequence with the side-effecting behavior applied.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"onNext\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence.",
                "ImportedHelp": "<param name=\"source\">Source sequence.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Action<TSource>",
              "PinAttribute": {
                "Help": "Action to invoke for each element in the observable sequence.",
                "ImportedHelp": "<param name=\"onNext\">Action to invoke for each element in the observable sequence.</param>"
              },
              "DotNetName": "onNext"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "The source sequence with the side-effecting behavior applied.",
              "ImportedHelp": "<returns>The source sequence with the side-effecting behavior applied.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Do"
        },
        {
          "NodeAttribute": {
            "Name": "ElementAt",
            "Category": "System.Reactive.Linq",
            "Help": "Returns the element at a specified index in a sequence.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.ElementAt``1(System.IObservable{``0},System.Int32)\">\r\n  <summary>\r\n            Returns the element at a specified index in a sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Observable sequence to return the element from.</param>\r\n  <param name=\"index\">The zero-based index of the element to retrieve.</param>\r\n  <returns>An observable sequence that produces the element at the specified position in the source sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"index\" /> is less than zero.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">(Asynchronous) <paramref name=\"index\" /> is greater than or equal to the number of elements in the source sequence.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Observable sequence to return the element from.",
                "ImportedHelp": "<param name=\"source\">Observable sequence to return the element from.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Int32",
              "PinAttribute": {
                "Help": "The zero-based index of the element to retrieve.",
                "ImportedHelp": "<param name=\"index\">The zero-based index of the element to retrieve.</param>"
              },
              "DotNetName": "index"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence that produces the element at the specified position in the source sequence.",
              "ImportedHelp": "<returns>An observable sequence that produces the element at the specified position in the source sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "ElementAt"
        },
        {
          "NodeAttribute": {
            "Name": "Empty",
            "Category": "Reactive.Observable",
            "Help": "Returns an empty observable sequence.TResult: The type used for the IObservable<T> type parameter of the resulting sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Empty``1\">\r\n  <summary>\r\n            Returns an empty observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type used for the IObservable&lt;T&gt; type parameter of the resulting sequence.</typeparam>\r\n  <returns>An observable sequence with no elements.</returns>\r\n</member>",
            "IsDefaultValue": true
          },
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "An observable sequence with no elements.",
              "ImportedHelp": "<returns>An observable sequence with no elements.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Empty"
        },
        {
          "NodeAttribute": {
            "Name": "Finally",
            "Category": "Reactive.Observable",
            "Help": "Invokes a specified action after the source observable sequence terminates gracefully or exceptionally.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Finally``1(System.IObservable{``0},System.Action)\">\r\n  <summary>\r\n            Invokes a specified action after the source observable sequence terminates gracefully or exceptionally.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence.</param>\r\n  <param name=\"finallyAction\">Action to invoke after the source observable sequence terminates.</param>\r\n  <returns>Source sequence with the action-invoking termination behavior applied.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"finallyAction\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence.",
                "ImportedHelp": "<param name=\"source\">Source sequence.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Action",
              "PinAttribute": {
                "Help": "Action to invoke after the source observable sequence terminates.",
                "ImportedHelp": "<param name=\"finallyAction\">Action to invoke after the source observable sequence terminates.</param>"
              },
              "DotNetName": "finallyAction"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "Source sequence with the action-invoking termination behavior applied.",
              "ImportedHelp": "<returns>Source sequence with the action-invoking termination behavior applied.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Finally"
        },
        {
          "NodeAttribute": {
            "Name": "First",
            "Category": "Reactive.Observable",
            "Help": "Returns the first element of an observable sequence.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.First``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Returns the first element of an observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source observable sequence.</param>\r\n  <returns>The first element in the observable sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.InvalidOperationException\">The source sequence is empty.</exception>\r\n  <seealso cref=\"M:System.Reactive.Linq.Observable.FirstAsync``1(System.IObservable{``0})\" />\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source observable sequence.",
                "ImportedHelp": "<param name=\"source\">Source observable sequence.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "TSource",
            "PinAttribute": {
              "Help": "The first element in the observable sequence.",
              "ImportedHelp": "<returns>The first element in the observable sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "First"
        },
        {
          "NodeAttribute": {
            "Name": "First",
            "Version": "Selector",
            "Category": "Reactive.Observable",
            "Help": "Returns the first element of an observable sequence that satisfies the condition in the predicate.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.First``1(System.IObservable{``0},System.Func{``0,System.Boolean})\">\r\n  <summary>\r\n            Returns the first element of an observable sequence that satisfies the condition in the predicate.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source observable sequence.</param>\r\n  <param name=\"predicate\">A predicate function to evaluate for elements in the source sequence.</param>\r\n  <returns>The first element in the observable sequence that satisfies the condition in the predicate.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"predicate\" /> is null.</exception>\r\n  <exception cref=\"T:System.InvalidOperationException\">No element satisfies the condition in the predicate. -or- The source sequence is empty.</exception>\r\n  <seealso cref=\"M:System.Reactive.Linq.Observable.FirstAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})\" />\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source observable sequence.",
                "ImportedHelp": "<param name=\"source\">Source observable sequence.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, System.Boolean>",
              "PinAttribute": {
                "Help": "A predicate function to evaluate for elements in the source sequence.",
                "ImportedHelp": "<param name=\"predicate\">A predicate function to evaluate for elements in the source sequence.</param>"
              },
              "DotNetName": "predicate"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "TSource",
            "PinAttribute": {
              "Help": "The first element in the observable sequence that satisfies the condition in the predicate.",
              "ImportedHelp": "<returns>The first element in the observable sequence that satisfies the condition in the predicate.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "First"
        },
        {
          "NodeAttribute": {
            "Name": "ForEach",
            "Category": "Reactive.Observable",
            "Help": "Invokes an action for each element in the observable sequence, incorporating the element's index, and blocks until the sequence is terminated.\r\nRemarks: Because of its blocking nature, this operator is mainly used for testing.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.ForEach``1(System.IObservable{``0},System.Action{``0,System.Int32})\">\r\n  <summary>\r\n            Invokes an action for each element in the observable sequence, incorporating the element's index, and blocks until the sequence is terminated.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence.</param>\r\n  <param name=\"onNext\">Action to invoke for each element in the observable sequence.</param>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"onNext\" /> is null.</exception>\r\n  <remarks>Because of its blocking nature, this operator is mainly used for testing.</remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence.",
                "ImportedHelp": "<param name=\"source\">Source sequence.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Action<TSource, System.Int32>",
              "PinAttribute": {
                "Help": "Action to invoke for each element in the observable sequence.",
                "ImportedHelp": "<param name=\"onNext\">Action to invoke for each element in the observable sequence.</param>"
              },
              "DotNetName": "onNext"
            }
          ],
          "DotNetName": "ForEach"
        },
        {
          "NodeAttribute": {
            "Name": "FromSequence",
            "Category": "Reactive.Observable",
            "Help": "Converts an enumerable sequence to an observable sequence.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0})\">\r\n  <summary>\r\n            Converts an enumerable sequence to an observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Enumerable sequence to convert to an observable sequence.</param>\r\n  <returns>The observable sequence whose elements are pulled from the given enumerable sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Collections.Generic.IEnumerable<TSource>",
              "PinAttribute": {
                "Help": "Enumerable sequence to convert to an observable sequence.",
                "ImportedHelp": "<param name=\"source\">Enumerable sequence to convert to an observable sequence.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "The observable sequence whose elements are pulled from the given enumerable sequence.",
              "ImportedHelp": "<returns>The observable sequence whose elements are pulled from the given enumerable sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "ToObservable"
        },
        {
          "NodeAttribute": {
            "Name": "GroupBy",
            "Category": "Reactive.Observable",
            "Help": "Groups the elements of an observable sequence according to a specified key selector function.TSource: The type of the elements in the source sequence.\r\nTKey: The type of the grouping key computed for each element in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.GroupBy``2(System.IObservable{``0},System.Func{``0,``1})\">\r\n  <summary>\r\n            Groups the elements of an observable sequence according to a specified key selector function.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TKey\">The type of the grouping key computed for each element in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence whose elements to group.</param>\r\n  <param name=\"keySelector\">A function to extract the key for each element.</param>\r\n  <returns>A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"keySelector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence whose elements to group.",
                "ImportedHelp": "<param name=\"source\">An observable sequence whose elements to group.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, TKey>",
              "PinAttribute": {
                "Help": "A function to extract the key for each element.",
                "ImportedHelp": "<param name=\"keySelector\">A function to extract the key for each element.</param>"
              },
              "DotNetName": "keySelector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Reactive.Linq.IGroupedObservable<TKey, TSource>>",
            "PinAttribute": {
              "Help": "A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.",
              "ImportedHelp": "<returns>A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "GroupBy"
        },
        {
          "NodeAttribute": {
            "Name": "If",
            "Category": "Reactive.Observable",
            "Help": "If the specified Condition evaluates true, select the Then Source sequence. Otherwise, return an empty sequence.TResult: The type of the elements in the result sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.If``1(System.Func{System.Boolean},System.IObservable{``0})\">\r\n  <summary>\r\n            If the specified <paramref name=\"condition\" /> evaluates true, select the <paramref name=\"thenSource\" /> sequence. Otherwise, return an empty sequence.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence.</typeparam>\r\n  <param name=\"condition\">Condition evaluated to decide which sequence to return.</param>\r\n  <param name=\"thenSource\">Sequence returned in case <paramref name=\"condition\" /> evaluates true.</param>\r\n  <returns>\r\n    <paramref name=\"thenSource\" /> if <paramref name=\"condition\" /> evaluates true; an empty sequence otherwise.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"condition\" /> or <paramref name=\"thenSource\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<System.Boolean>",
              "PinAttribute": {
                "Help": "Condition evaluated to decide which sequence to return.",
                "ImportedHelp": "<param name=\"condition\">Condition evaluated to decide which sequence to return.</param>"
              },
              "DotNetName": "condition"
            },
            {
              "TypeFullName": "System.IObservable<TResult>",
              "PinAttribute": {
                "Help": "Sequence returned in case Condition evaluates true.",
                "ImportedHelp": "<param name=\"thenSource\">Sequence returned in case <paramref name=\"condition\" /> evaluates true.</param>"
              },
              "DotNetName": "thenSource"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "Then Source if Condition evaluates true; an empty sequence otherwise.",
              "ImportedHelp": "<returns>\r\n  <paramref name=\"thenSource\" /> if <paramref name=\"condition\" /> evaluates true; an empty sequence otherwise.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "If"
        },
        {
          "NodeAttribute": {
            "Name": "IfElse",
            "Category": "Reactive.Observable",
            "Help": "If the specified Condition evaluates true, select the Then Source sequence. Otherwise, select the Else Source sequence.TResult: The type of the elements in the result sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.If``1(System.Func{System.Boolean},System.IObservable{``0},System.IObservable{``0})\">\r\n  <summary>\r\n            If the specified <paramref name=\"condition\" /> evaluates true, select the <paramref name=\"thenSource\" /> sequence. Otherwise, select the <paramref name=\"elseSource\" /> sequence.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence.</typeparam>\r\n  <param name=\"condition\">Condition evaluated to decide which sequence to return.</param>\r\n  <param name=\"thenSource\">Sequence returned in case <paramref name=\"condition\" /> evaluates true.</param>\r\n  <param name=\"elseSource\">Sequence returned in case <paramref name=\"condition\" /> evaluates false.</param>\r\n  <returns>\r\n    <paramref name=\"thenSource\" /> if <paramref name=\"condition\" /> evaluates true; <paramref name=\"elseSource\" /> otherwise.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"condition\" /> or <paramref name=\"thenSource\" /> or <paramref name=\"elseSource\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<System.Boolean>",
              "PinAttribute": {
                "Help": "Condition evaluated to decide which sequence to return.",
                "ImportedHelp": "<param name=\"condition\">Condition evaluated to decide which sequence to return.</param>"
              },
              "DotNetName": "condition"
            },
            {
              "TypeFullName": "System.IObservable<TResult>",
              "PinAttribute": {
                "Help": "Sequence returned in case Condition evaluates true.",
                "ImportedHelp": "<param name=\"thenSource\">Sequence returned in case <paramref name=\"condition\" /> evaluates true.</param>"
              },
              "DotNetName": "thenSource"
            },
            {
              "TypeFullName": "System.IObservable<TResult>",
              "PinAttribute": {
                "Help": "Sequence returned in case Condition evaluates false.",
                "ImportedHelp": "<param name=\"elseSource\">Sequence returned in case <paramref name=\"condition\" /> evaluates false.</param>"
              },
              "DotNetName": "elseSource"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "Then Source if Condition evaluates true; Else Source otherwise.",
              "ImportedHelp": "<returns>\r\n  <paramref name=\"thenSource\" /> if <paramref name=\"condition\" /> evaluates true; <paramref name=\"elseSource\" /> otherwise.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "If"
        },
        {
          "NodeAttribute": {
            "Name": "IgnoreElements",
            "Category": "Reactive.Observable",
            "Help": "Ignores all elements in an observable sequence leaving only the termination messages.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.IgnoreElements``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Ignores all elements in an observable sequence leaving only the termination messages.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence.</param>\r\n  <returns>An empty observable sequence that signals termination, successful or exceptional, of the source sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence.",
                "ImportedHelp": "<param name=\"source\">Source sequence.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An empty observable sequence that signals termination, successful or exceptional, of the source sequence.",
              "ImportedHelp": "<returns>An empty observable sequence that signals termination, successful or exceptional, of the source sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "IgnoreElements"
        },
        {
          "NodeAttribute": {
            "Name": "Interval",
            "Category": "Reactive.Observable",
            "Help": "Returns an observable sequence that produces a value after each period.\r\nRemarks: Intervals are measured between the start of subsequent notifications, not between the end of the previous and the start of the next notification.\n            If the observer takes longer than the interval period to handle the message, the subsequent notification will be delivered immediately after the\n            current one has been handled. In case you need to control the time between the end and the start of consecutive notifications, consider using the\n            M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.TimeSpan})\n            operator instead.",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Interval(System.TimeSpan)\">\r\n  <summary>\r\n            Returns an observable sequence that produces a value after each period.\r\n            </summary>\r\n  <param name=\"period\">Period for producing the values in the resulting sequence. If this value is equal to TimeSpan.Zero, the timer will recur as fast as possible.</param>\r\n  <returns>An observable sequence that produces a value after each period.</returns>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"period\" /> is less than TimeSpan.Zero.</exception>\r\n  <remarks>\r\n            Intervals are measured between the start of subsequent notifications, not between the end of the previous and the start of the next notification.\r\n            If the observer takes longer than the interval period to handle the message, the subsequent notification will be delivered immediately after the\r\n            current one has been handled. In case you need to control the time between the end and the start of consecutive notifications, consider using the\r\n            <see cref=\"M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.TimeSpan})\" />\r\n            operator instead.\r\n            </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Period for producing the values in the resulting sequence. If this value is equal to TimeSpan.Zero, the timer will recur as fast as possible.",
                "ImportedHelp": "<param name=\"period\">Period for producing the values in the resulting sequence. If this value is equal to TimeSpan.Zero, the timer will recur as fast as possible.</param>"
              },
              "DotNetName": "period"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Int64>",
            "PinAttribute": {
              "Help": "An observable sequence that produces a value after each period.",
              "ImportedHelp": "<returns>An observable sequence that produces a value after each period.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Interval"
        },
        {
          "NodeAttribute": {
            "Name": "IsEmpty",
            "Category": "Reactive.Observable",
            "Help": "Determines whether an observable sequence is empty.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.IsEmpty``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Determines whether an observable sequence is empty.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence to check for emptiness.</param>\r\n  <returns>An observable sequence containing a single element determining whether the source sequence is empty.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence to check for emptiness.",
                "ImportedHelp": "<param name=\"source\">An observable sequence to check for emptiness.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Boolean>",
            "PinAttribute": {
              "Help": "An observable sequence containing a single element determining whether the source sequence is empty.",
              "ImportedHelp": "<returns>An observable sequence containing a single element determining whether the source sequence is empty.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "IsEmpty"
        },
        {
          "NodeAttribute": {
            "Name": "Merge",
            "Category": "Reactive.Observable",
            "Help": "Merges elements from two observable sequences into a single observable sequence.TSource: The type of the elements in the source sequences.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{``0},System.IObservable{``0})\">\r\n  <summary>\r\n            Merges elements from two observable sequences into a single observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequences.</typeparam>\r\n  <param name=\"first\">First observable sequence.</param>\r\n  <param name=\"second\">Second observable sequence.</param>\r\n  <returns>The observable sequence that merges the elements of the given sequences.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"first\" /> or <paramref name=\"second\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "First observable sequence.",
                "ImportedHelp": "<param name=\"first\">First observable sequence.</param>"
              },
              "DotNetName": "first"
            },
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Name": "Input 2",
                "Help": "Second observable sequence.",
                "ImportedHelp": "<param name=\"second\">Second observable sequence.</param>"
              },
              "DotNetName": "second"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "The observable sequence that merges the elements of the given sequences.",
              "ImportedHelp": "<returns>The observable sequence that merges the elements of the given sequences.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Merge"
        },
        {
          "NodeAttribute": {
            "Name": "Merge",
            "Version": "Spectral",
            "Category": "Reactive.Observable",
            "Help": "Merges elements from all observable sequences in the given enumerable sequence into a single observable sequence.TSource: The type of the elements in the source sequences.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Merge``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})\">\r\n  <summary>\r\n            Merges elements from all observable sequences in the given enumerable sequence into a single observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequences.</typeparam>\r\n  <param name=\"sources\">Enumerable sequence of observable sequences.</param>\r\n  <returns>The observable sequence that merges the elements of the observable sequences.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"sources\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Collections.Generic.IEnumerable<System.IObservable<TSource>>",
              "PinAttribute": {
                "Help": "Enumerable sequence of observable sequences.",
                "ImportedHelp": "<param name=\"sources\">Enumerable sequence of observable sequences.</param>"
              },
              "DotNetName": "sources"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "The observable sequence that merges the elements of the observable sequences.",
              "ImportedHelp": "<returns>The observable sequence that merges the elements of the observable sequences.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Merge"
        },
        {
          "NodeAttribute": {
            "Name": "MostRecent",
            "Category": "Reactive.Observable",
            "Help": "Returns an enumerable sequence whose enumeration returns the most recently observed element in the source observable sequence, using the specified initial value in case no element has been sampled yet.\n            Enumerators on the resulting sequence never block and can produce the same element repeatedly.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.MostRecent``1(System.IObservable{``0},``0)\">\r\n  <summary>\r\n            Returns an enumerable sequence whose enumeration returns the most recently observed element in the source observable sequence, using the specified initial value in case no element has been sampled yet.\r\n            Enumerators on the resulting sequence never block and can produce the same element repeatedly.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source observable sequence.</param>\r\n  <param name=\"initialValue\">Initial value that will be yielded by the enumerable sequence if no element has been sampled yet.</param>\r\n  <returns>The enumerable sequence that returns the last sampled element upon each iteration.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source observable sequence.",
                "ImportedHelp": "<param name=\"source\">Source observable sequence.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "TSource",
              "PinAttribute": {
                "Help": "Initial value that will be yielded by the enumerable sequence if no element has been sampled yet.",
                "ImportedHelp": "<param name=\"initialValue\">Initial value that will be yielded by the enumerable sequence if no element has been sampled yet.</param>"
              },
              "DotNetName": "initialValue"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Collections.Generic.IEnumerable<TSource>",
            "PinAttribute": {
              "Help": "The enumerable sequence that returns the last sampled element upon each iteration.",
              "ImportedHelp": "<returns>The enumerable sequence that returns the last sampled element upon each iteration.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "MostRecent"
        },
        {
          "NodeAttribute": {
            "Name": "Never",
            "Category": "Reactive.Observable",
            "Help": "Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).TResult: The type used for the IObservable<T> type parameter of the resulting sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Never``1\">\r\n  <summary>\r\n            Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type used for the IObservable&lt;T&gt; type parameter of the resulting sequence.</typeparam>\r\n  <returns>An observable sequence whose observers will never get called.</returns>\r\n</member>"
          },
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "An observable sequence whose observers will never get called.",
              "ImportedHelp": "<returns>An observable sequence whose observers will never get called.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Never"
        },
        {
          "NodeAttribute": {
            "Name": "OfType",
            "Category": "Reactive.Observable",
            "Help": "Filters the elements of an observable sequence based on the specified type.TResult: The type to filter the elements in the source sequence on.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.OfType``1(System.IObservable{System.Object})\">\r\n  <summary>\r\n            Filters the elements of an observable sequence based on the specified type.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type to filter the elements in the source sequence on.</typeparam>\r\n  <param name=\"source\">The observable sequence that contains the elements to be filtered.</param>\r\n  <returns>An observable sequence that contains elements from the input sequence of type TResult.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<System.Object>",
              "PinAttribute": {
                "Help": "The observable sequence that contains the elements to be filtered.",
                "ImportedHelp": "<param name=\"source\">The observable sequence that contains the elements to be filtered.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "An observable sequence that contains elements from the input sequence of type TResult.",
              "ImportedHelp": "<returns>An observable sequence that contains elements from the input sequence of type TResult.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "OfType"
        },
        {
          "NodeAttribute": {
            "Name": "Project",
            "Category": "Reactive.Observable",
            "Help": "Projects each element of an observable sequence into a new form by incorporating the element's index.TSource: The type of the elements in the source sequence.\r\nTResult: The type of the elements in the result sequence, obtained by running the selector function for each element in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Select``2(System.IObservable{``0},System.Func{``0,System.Int32,``1})\">\r\n  <summary>\r\n            Projects each element of an observable sequence into a new form by incorporating the element's index.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence, obtained by running the selector function for each element in the source sequence.</typeparam>\r\n  <param name=\"source\">A sequence of elements to invoke a transform function on.</param>\r\n  <param name=\"selector\">A transform function to apply to each source element; the second parameter of the function represents the index of the source element.</param>\r\n  <returns>An observable sequence whose elements are the result of invoking the transform function on each element of source.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"selector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "A sequence of elements to invoke a transform function on.",
                "ImportedHelp": "<param name=\"source\">A sequence of elements to invoke a transform function on.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, System.Int32, TResult>",
              "PinAttribute": {
                "Help": "A transform function to apply to each source element; the second parameter of the function represents the index of the source element.",
                "ImportedHelp": "<param name=\"selector\">A transform function to apply to each source element; the second parameter of the function represents the index of the source element.</param>"
              },
              "DotNetName": "selector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "An observable sequence whose elements are the result of invoking the transform function on each element of source.",
              "ImportedHelp": "<returns>An observable sequence whose elements are the result of invoking the transform function on each element of source.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Select"
        },
        {
          "NodeAttribute": {
            "Name": "Project",
            "Version": "Many",
            "Category": "Reactive.Observable",
            "Help": "Projects each element of an observable sequence to an observable sequence by incorporating the element's index and merges the resulting observable sequences into one observable sequence.TSource: The type of the elements in the source sequence.\r\nTResult: The type of the elements in the projected inner sequences and the elements in the merged result sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Int32,System.IObservable{``1}})\">\r\n  <summary>\r\n            Projects each element of an observable sequence to an observable sequence by incorporating the element's index and merges the resulting observable sequences into one observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TResult\">The type of the elements in the projected inner sequences and the elements in the merged result sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence of elements to project.</param>\r\n  <param name=\"selector\">A transform function to apply to each element; the second parameter of the function represents the index of the source element.</param>\r\n  <returns>An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"selector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence of elements to project.",
                "ImportedHelp": "<param name=\"source\">An observable sequence of elements to project.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, System.Int32, System.IObservable<TResult>>",
              "PinAttribute": {
                "Help": "A transform function to apply to each element; the second parameter of the function represents the index of the source element.",
                "ImportedHelp": "<param name=\"selector\">A transform function to apply to each element; the second parameter of the function represents the index of the source element.</param>"
              },
              "DotNetName": "selector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.",
              "ImportedHelp": "<returns>An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "SelectMany"
        },
        {
          "NodeAttribute": {
            "Name": "Publish",
            "Category": "Reactive.Observable",
            "Help": "Returns a connectable observable sequence that shares a single subscription to the underlying sequence.\n            This operator is a specialization of Multicast using a regular T:System.Reactive.Subjects.Subject`1.\r\nRemarks: Subscribers will receive all notifications of the source from the time of the subscription on.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Publish``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Returns a connectable observable sequence that shares a single subscription to the underlying sequence.\r\n            This operator is a specialization of Multicast using a regular <see cref=\"T:System.Reactive.Subjects.Subject`1\" />.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence whose elements will be multicasted through a single shared subscription.</param>\r\n  <returns>A connectable observable sequence that shares a single subscription to the underlying sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <remarks>Subscribers will receive all notifications of the source from the time of the subscription on.</remarks>\r\n  <seealso cref=\"T:System.Reactive.Subjects.Subject`1\" />\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence whose elements will be multicasted through a single shared subscription.",
                "ImportedHelp": "<param name=\"source\">Source sequence whose elements will be multicasted through a single shared subscription.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Subjects.IConnectableObservable<TSource>",
            "PinAttribute": {
              "Help": "A connectable observable sequence that shares a single subscription to the underlying sequence.",
              "ImportedHelp": "<returns>A connectable observable sequence that shares a single subscription to the underlying sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Publish"
        },
        {
          "NodeAttribute": {
            "Name": "Range",
            "Category": "Reactive.Observable",
            "Help": "Generates an observable sequence of integral numbers within a specified range.",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Range(System.Int32,System.Int32)\">\r\n  <summary>\r\n            Generates an observable sequence of integral numbers within a specified range.\r\n            </summary>\r\n  <param name=\"start\">The value of the first integer in the sequence.</param>\r\n  <param name=\"count\">The number of sequential integers to generate.</param>\r\n  <returns>An observable sequence that contains a range of sequential integral numbers.</returns>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"count\" /> is less than zero. -or- <paramref name=\"start\" /> + <paramref name=\"count\" /> - 1 is larger than <see cref=\"M:System.Int32.MaxValue\" />.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Int32",
              "PinAttribute": {
                "Help": "The value of the first integer in the sequence.",
                "ImportedHelp": "<param name=\"start\">The value of the first integer in the sequence.</param>"
              },
              "DotNetName": "start"
            },
            {
              "TypeFullName": "System.Int32",
              "PinAttribute": {
                "Help": "The number of sequential integers to generate.",
                "ImportedHelp": "<param name=\"count\">The number of sequential integers to generate.</param>"
              },
              "DotNetName": "count"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Int32>",
            "PinAttribute": {
              "Help": "An observable sequence that contains a range of sequential integral numbers.",
              "ImportedHelp": "<returns>An observable sequence that contains a range of sequential integral numbers.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Range"
        },
        {
          "NodeAttribute": {
            "Name": "RefCount",
            "Category": "Reactive.Observable",
            "Help": "Returns an observable sequence that stays connected to the source as long as there is at least one subscription to the observable sequence.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.RefCount``1(System.Reactive.Subjects.IConnectableObservable{``0})\">\r\n  <summary>\r\n            Returns an observable sequence that stays connected to the source as long as there is at least one subscription to the observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Connectable observable sequence.</param>\r\n  <returns>An observable sequence that stays connected to the source as long as there is at least one subscription to the observable sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Reactive.Subjects.IConnectableObservable<TSource>",
              "PinAttribute": {
                "Help": "Connectable observable sequence.",
                "ImportedHelp": "<param name=\"source\">Connectable observable sequence.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence that stays connected to the source as long as there is at least one subscription to the observable sequence.",
              "ImportedHelp": "<returns>An observable sequence that stays connected to the source as long as there is at least one subscription to the observable sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "RefCount"
        },
        {
          "NodeAttribute": {
            "Name": "Repeat",
            "Category": "Reactive.Observable",
            "Help": "Generates an observable sequence that repeats the given element the specified number of times.TResult: The type of the element that will be repeated in the produced sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Repeat``1(``0,System.Int32)\">\r\n  <summary>\r\n            Generates an observable sequence that repeats the given element the specified number of times.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the element that will be repeated in the produced sequence.</typeparam>\r\n  <param name=\"value\">Element to repeat.</param>\r\n  <param name=\"repeatCount\">Number of times to repeat the element.</param>\r\n  <returns>An observable sequence that repeats the given element the specified number of times.</returns>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"repeatCount\" /> is less than zero.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "TResult",
              "PinAttribute": {
                "Help": "Element to repeat.",
                "ImportedHelp": "<param name=\"value\">Element to repeat.</param>"
              },
              "DotNetName": "value"
            },
            {
              "TypeFullName": "System.Int32",
              "PinAttribute": {
                "Help": "Number of times to repeat the element.",
                "ImportedHelp": "<param name=\"repeatCount\">Number of times to repeat the element.</param>"
              },
              "DotNetName": "repeatCount"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "An observable sequence that repeats the given element the specified number of times.",
              "ImportedHelp": "<returns>An observable sequence that repeats the given element the specified number of times.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Repeat"
        },
        {
          "NodeAttribute": {
            "Name": "Return",
            "Category": "Reactive.Observable",
            "Help": "Returns an observable sequence that contains a single element.TResult: The type of the element that will be returned in the produced sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Return``1(``0)\">\r\n  <summary>\r\n            Returns an observable sequence that contains a single element.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the element that will be returned in the produced sequence.</typeparam>\r\n  <param name=\"value\">Single element in the resulting observable sequence.</param>\r\n  <returns>An observable sequence containing the single specified element.</returns>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "TResult",
              "PinAttribute": {
                "Help": "Single element in the resulting observable sequence.",
                "ImportedHelp": "<param name=\"value\">Single element in the resulting observable sequence.</param>"
              },
              "DotNetName": "value"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "An observable sequence containing the single specified element.",
              "ImportedHelp": "<returns>An observable sequence containing the single specified element.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Return"
        },
        {
          "NodeAttribute": {
            "Name": "Sample",
            "Category": "Reactive.Observable",
            "Help": "Samples the observable sequence at each interval.\n            Upon each sampling tick, the latest element (if any) in the source sequence during the last sampling interval is sent to the resulting sequence.\r\nRemarks: Specifying a TimeSpan.Zero value for Interval doesn't guarantee all source sequence elements will be preserved. This is a side-effect\n            of the asynchrony introduced by the scheduler, where the sampling action may not execute immediately, despite the TimeSpan.Zero due time.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Sample``1(System.IObservable{``0},System.TimeSpan)\">\r\n  <summary>\r\n            Samples the observable sequence at each interval.\r\n            Upon each sampling tick, the latest element (if any) in the source sequence during the last sampling interval is sent to the resulting sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to sample.</param>\r\n  <param name=\"interval\">Interval at which to sample. If this value is equal to TimeSpan.Zero, the scheduler will continuously sample the stream.</param>\r\n  <returns>Sampled observable sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"interval\" /> is less than TimeSpan.Zero.</exception>\r\n  <remarks>\r\n            Specifying a TimeSpan.Zero value for <paramref name=\"interval\" /> doesn't guarantee all source sequence elements will be preserved. This is a side-effect\r\n            of the asynchrony introduced by the scheduler, where the sampling action may not execute immediately, despite the TimeSpan.Zero due time.\r\n            </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to sample.",
                "ImportedHelp": "<param name=\"source\">Source sequence to sample.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Interval at which to sample. If this value is equal to TimeSpan.Zero, the scheduler will continuously sample the stream.",
                "ImportedHelp": "<param name=\"interval\">Interval at which to sample. If this value is equal to TimeSpan.Zero, the scheduler will continuously sample the stream.</param>"
              },
              "DotNetName": "interval"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "Sampled observable sequence.",
              "ImportedHelp": "<returns>Sampled observable sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Sample"
        },
        {
          "NodeAttribute": {
            "Name": "Sample",
            "Version": "Sampler",
            "Category": "Reactive.Observable",
            "Help": "Samples the source observable sequence using a samper observable sequence producing sampling ticks.\n            Upon each sampling tick, the latest element (if any) in the source sequence during the last sampling interval is sent to the resulting sequence.TSource: The type of the elements in the source sequence.\r\nTSample: The type of the elements in the sampling sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Sample``2(System.IObservable{``0},System.IObservable{``1})\">\r\n  <summary>\r\n            Samples the source observable sequence using a samper observable sequence producing sampling ticks.\r\n            Upon each sampling tick, the latest element (if any) in the source sequence during the last sampling interval is sent to the resulting sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TSample\">The type of the elements in the sampling sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to sample.</param>\r\n  <param name=\"sampler\">Sampling tick sequence.</param>\r\n  <returns>Sampled observable sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"sampler\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to sample.",
                "ImportedHelp": "<param name=\"source\">Source sequence to sample.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.IObservable<TSample>",
              "PinAttribute": {
                "Help": "Sampling tick sequence.",
                "ImportedHelp": "<param name=\"sampler\">Sampling tick sequence.</param>"
              },
              "DotNetName": "sampler"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "Sampled observable sequence.",
              "ImportedHelp": "<returns>Sampled observable sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Sample"
        },
        {
          "NodeAttribute": {
            "Name": "Scan",
            "Category": "Reactive.Observable",
            "Help": "Applies an accumulator function over an observable sequence and returns each intermediate result. The specified seed value is used as the initial accumulator value.\n            For aggregation behavior with no intermediate results, see Aggregate.TSource: The type of the elements in the source sequence.\r\nTAccumulate: The type of the result of the aggregation.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Scan``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})\">\r\n  <summary>\r\n            Applies an accumulator function over an observable sequence and returns each intermediate result. The specified seed value is used as the initial accumulator value.\r\n            For aggregation behavior with no intermediate results, see <see cref=\"M:System.Reactive.Linq.Observable.Aggregate``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})\" />.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TAccumulate\">The type of the result of the aggregation.</typeparam>\r\n  <param name=\"source\">An observable sequence to accumulate over.</param>\r\n  <param name=\"seed\">The initial accumulator value.</param>\r\n  <param name=\"accumulator\">An accumulator function to be invoked on each element.</param>\r\n  <returns>An observable sequence containing the accumulated values.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"accumulator\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence to accumulate over.",
                "ImportedHelp": "<param name=\"source\">An observable sequence to accumulate over.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "TAccumulate",
              "PinAttribute": {
                "Help": "The initial accumulator value.",
                "ImportedHelp": "<param name=\"seed\">The initial accumulator value.</param>"
              },
              "DotNetName": "seed"
            },
            {
              "TypeFullName": "System.Func<TAccumulate, TSource, TAccumulate>",
              "PinAttribute": {
                "Help": "An accumulator function to be invoked on each element.",
                "ImportedHelp": "<param name=\"accumulator\">An accumulator function to be invoked on each element.</param>"
              },
              "DotNetName": "accumulator"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TAccumulate>",
            "PinAttribute": {
              "Help": "An observable sequence containing the accumulated values.",
              "ImportedHelp": "<returns>An observable sequence containing the accumulated values.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Scan"
        },
        {
          "NodeAttribute": {
            "Name": "SequenceEqual",
            "Category": "Reactive.Observable",
            "Help": "Determines whether two sequences are equal by comparing the elements pairwise.\r\nRemarks: The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.SequenceEqual``1(System.IObservable{``0},System.IObservable{``0})\">\r\n  <summary>\r\n            Determines whether two sequences are equal by comparing the elements pairwise.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"first\">First observable sequence to compare.</param>\r\n  <param name=\"second\">Second observable sequence to compare.</param>\r\n  <returns>An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the default equality comparer for their type.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"first\" /> or <paramref name=\"second\" /> is null.</exception>\r\n  <remarks>The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.</remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "First observable sequence to compare.",
                "ImportedHelp": "<param name=\"first\">First observable sequence to compare.</param>"
              },
              "DotNetName": "first"
            },
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Second observable sequence to compare.",
                "ImportedHelp": "<param name=\"second\">Second observable sequence to compare.</param>"
              },
              "DotNetName": "second"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Boolean>",
            "PinAttribute": {
              "Help": "An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the default equality comparer for their type.",
              "ImportedHelp": "<returns>An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the default equality comparer for their type.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "SequenceEqual"
        },
        {
          "NodeAttribute": {
            "Name": "Skip",
            "Category": "Reactive.Observable",
            "Help": "Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Skip``1(System.IObservable{``0},System.Int32)\">\r\n  <summary>\r\n            Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">The sequence to take elements from.</param>\r\n  <param name=\"count\">The number of elements to skip before returning the remaining elements.</param>\r\n  <returns>An observable sequence that contains the elements that occur after the specified index in the input sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"count\" /> is less than zero.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "The sequence to take elements from.",
                "ImportedHelp": "<param name=\"source\">The sequence to take elements from.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Int32",
              "PinAttribute": {
                "Help": "The number of elements to skip before returning the remaining elements.",
                "ImportedHelp": "<param name=\"count\">The number of elements to skip before returning the remaining elements.</param>"
              },
              "DotNetName": "count"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence that contains the elements that occur after the specified index in the input sequence.",
              "ImportedHelp": "<returns>An observable sequence that contains the elements that occur after the specified index in the input sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Skip"
        },
        {
          "NodeAttribute": {
            "Name": "Skip",
            "Version": "Duration",
            "Category": "Reactive.Observable",
            "Help": "Skips elements for the specified duration from the start of the observable source sequence.\r\nRemarks: Specifying a TimeSpan.Zero value for Duration doesn't guarantee no elements will be dropped from the start of the source sequence.\n            This is a side-effect of the asynchrony introduced by the scheduler, where the action that causes callbacks from the source sequence to be forwarded\n            may not execute immediately, despite the TimeSpan.Zero due time.Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the Duration.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Skip``1(System.IObservable{``0},System.TimeSpan)\">\r\n  <summary>\r\n            Skips elements for the specified duration from the start of the observable source sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to skip elements for.</param>\r\n  <param name=\"duration\">Duration for skipping elements from the start of the sequence.</param>\r\n  <returns>An observable sequence with the elements skipped during the specified duration from the start of the source sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"duration\" /> is less than TimeSpan.Zero.</exception>\r\n  <remarks>\r\n    <para>\r\n            Specifying a TimeSpan.Zero value for <paramref name=\"duration\" /> doesn't guarantee no elements will be dropped from the start of the source sequence.\r\n            This is a side-effect of the asynchrony introduced by the scheduler, where the action that causes callbacks from the source sequence to be forwarded\r\n            may not execute immediately, despite the TimeSpan.Zero due time.\r\n            </para>\r\n    <para>\r\n            Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the <paramref name=\"duration\" />.\r\n            </para>\r\n  </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to skip elements for.",
                "ImportedHelp": "<param name=\"source\">Source sequence to skip elements for.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Duration for skipping elements from the start of the sequence.",
                "ImportedHelp": "<param name=\"duration\">Duration for skipping elements from the start of the sequence.</param>"
              },
              "DotNetName": "duration"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence with the elements skipped during the specified duration from the start of the source sequence.",
              "ImportedHelp": "<returns>An observable sequence with the elements skipped during the specified duration from the start of the source sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Skip"
        },
        {
          "NodeAttribute": {
            "Name": "SkipLast",
            "Category": "Reactive.Observable",
            "Help": "Bypasses a specified number of elements at the end of an observable sequence.\r\nRemarks: This operator accumulates a queue with a length enough to store the first Count elements. As more elements are\n            received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.SkipLast``1(System.IObservable{``0},System.Int32)\">\r\n  <summary>\r\n            Bypasses a specified number of elements at the end of an observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence.</param>\r\n  <param name=\"count\">Number of elements to bypass at the end of the source sequence.</param>\r\n  <returns>An observable sequence containing the source sequence elements except for the bypassed ones at the end.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"count\" /> is less than zero.</exception>\r\n  <remarks>\r\n            This operator accumulates a queue with a length enough to store the first <paramref name=\"count\" /> elements. As more elements are\r\n            received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.\r\n            </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence.",
                "ImportedHelp": "<param name=\"source\">Source sequence.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Int32",
              "PinAttribute": {
                "Help": "Number of elements to bypass at the end of the source sequence.",
                "ImportedHelp": "<param name=\"count\">Number of elements to bypass at the end of the source sequence.</param>"
              },
              "DotNetName": "count"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence containing the source sequence elements except for the bypassed ones at the end.",
              "ImportedHelp": "<returns>An observable sequence containing the source sequence elements except for the bypassed ones at the end.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "SkipLast"
        },
        {
          "NodeAttribute": {
            "Name": "SkipLast",
            "Version": "Duration",
            "Category": "Reactive.Observable",
            "Help": "Skips elements for the specified duration from the end of the observable source sequence.\r\nRemarks: This operator accumulates a queue with a length enough to store elements received during the initial Duration window.\n            As more elements are received, elements older than the specified Duration are taken from the queue and produced on the\n            result sequence. This causes elements to be delayed with Duration.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.SkipLast``1(System.IObservable{``0},System.TimeSpan)\">\r\n  <summary>\r\n            Skips elements for the specified duration from the end of the observable source sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to skip elements for.</param>\r\n  <param name=\"duration\">Duration for skipping elements from the end of the sequence.</param>\r\n  <returns>An observable sequence with the elements skipped during the specified duration from the end of the source sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"duration\" /> is less than TimeSpan.Zero.</exception>\r\n  <remarks>\r\n            This operator accumulates a queue with a length enough to store elements received during the initial <paramref name=\"duration\" /> window.\r\n            As more elements are received, elements older than the specified <paramref name=\"duration\" /> are taken from the queue and produced on the\r\n            result sequence. This causes elements to be delayed with <paramref name=\"duration\" />.\r\n            </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to skip elements for.",
                "ImportedHelp": "<param name=\"source\">Source sequence to skip elements for.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Duration for skipping elements from the end of the sequence.",
                "ImportedHelp": "<param name=\"duration\">Duration for skipping elements from the end of the sequence.</param>"
              },
              "DotNetName": "duration"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence with the elements skipped during the specified duration from the end of the source sequence.",
              "ImportedHelp": "<returns>An observable sequence with the elements skipped during the specified duration from the end of the source sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "SkipLast"
        },
        {
          "NodeAttribute": {
            "Name": "SkipUntil",
            "Category": "Reactive.Observable",
            "Help": "Returns the elements from the source observable sequence only after the other observable sequence produces an element.TSource: The type of the elements in the source sequence.\r\nTOther: The type of the elements in the other sequence that indicates the end of skip behavior.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.SkipUntil``2(System.IObservable{``0},System.IObservable{``1})\">\r\n  <summary>\r\n            Returns the elements from the source observable sequence only after the other observable sequence produces an element.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TOther\">The type of the elements in the other sequence that indicates the end of skip behavior.</typeparam>\r\n  <param name=\"source\">Source sequence to propagate elements for.</param>\r\n  <param name=\"other\">Observable sequence that triggers propagation of elements of the source sequence.</param>\r\n  <returns>An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"other\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to propagate elements for.",
                "ImportedHelp": "<param name=\"source\">Source sequence to propagate elements for.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.IObservable<TOther>",
              "PinAttribute": {
                "Help": "Observable sequence that triggers propagation of elements of the source sequence.",
                "ImportedHelp": "<param name=\"other\">Observable sequence that triggers propagation of elements of the source sequence.</param>"
              },
              "DotNetName": "other"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.",
              "ImportedHelp": "<returns>An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "SkipUntil"
        },
        {
          "NodeAttribute": {
            "Name": "SkipWhile",
            "Category": "Reactive.Observable",
            "Help": "Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.SkipWhile``1(System.IObservable{``0},System.Func{``0,System.Boolean})\">\r\n  <summary>\r\n            Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence to return elements from.</param>\r\n  <param name=\"predicate\">A function to test each element for a condition.</param>\r\n  <returns>An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"predicate\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence to return elements from.",
                "ImportedHelp": "<param name=\"source\">An observable sequence to return elements from.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, System.Boolean>",
              "PinAttribute": {
                "Help": "A function to test each element for a condition.",
                "ImportedHelp": "<param name=\"predicate\">A function to test each element for a condition.</param>"
              },
              "DotNetName": "predicate"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.",
              "ImportedHelp": "<returns>An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "SkipWhile"
        },
        {
          "NodeAttribute": {
            "Name": "Start",
            "Category": "Reactive.Observable",
            "Help": "Invokes the specified function asynchronously, surfacing the result through an observable sequence.\r\nRemarks: The function is called immediately, not during the subscription of the resulting sequence.Multiple subscriptions to the resulting sequence can observe the function's result.TResult: The type of the result returned by the function.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Start``1(System.Func{``0})\">\r\n  <summary>\r\n            Invokes the specified function asynchronously, surfacing the result through an observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the result returned by the function.</typeparam>\r\n  <param name=\"function\">Function to run asynchronously.</param>\r\n  <returns>An observable sequence exposing the function's result value, or an exception.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"function\" /> is null.</exception>\r\n  <remarks>\r\n    <list type=\"bullet\">\r\n      <item>\r\n        <description>The function is called immediately, not during the subscription of the resulting sequence.</description>\r\n      </item>\r\n      <item>\r\n        <description>Multiple subscriptions to the resulting sequence can observe the function's result.</description>\r\n      </item>\r\n    </list>\r\n  </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<TResult>",
              "PinAttribute": {
                "Help": "Function to run asynchronously.",
                "ImportedHelp": "<param name=\"function\">Function to run asynchronously.</param>"
              },
              "DotNetName": "function"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TResult>",
            "PinAttribute": {
              "Help": "An observable sequence exposing the function's result value, or an exception.",
              "ImportedHelp": "<returns>An observable sequence exposing the function's result value, or an exception.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Start"
        },
        {
          "NodeAttribute": {
            "Name": "StartWith",
            "Category": "Reactive.Observable",
            "Help": "Prepends a sequence of values to an observable sequence.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.StartWith``1(System.IObservable{``0},System.Collections.Generic.IEnumerable{``0})\">\r\n  <summary>\r\n            Prepends a sequence of values to an observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to prepend values to.</param>\r\n  <param name=\"values\">Values to prepend to the specified sequence.</param>\r\n  <returns>The source sequence prepended with the specified values.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"values\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to prepend values to.",
                "ImportedHelp": "<param name=\"source\">Source sequence to prepend values to.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Collections.Generic.IEnumerable<TSource>",
              "PinAttribute": {
                "Help": "Values to prepend to the specified sequence.",
                "ImportedHelp": "<param name=\"values\">Values to prepend to the specified sequence.</param>"
              },
              "DotNetName": "values"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "The source sequence prepended with the specified values.",
              "ImportedHelp": "<returns>The source sequence prepended with the specified values.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "StartWith"
        },
        {
          "NodeAttribute": {
            "Name": "Switch",
            "Category": "Reactive.Observable",
            "Help": "Transforms an observable sequence of observable sequences into an observable sequence \n            producing values only from the most recent observable sequence.\n            Each time a new inner observable sequence is received, unsubscribe from the \n            previous inner observable sequence.TSource: The type of the elements in the source sequences.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Switch``1(System.IObservable{System.IObservable{``0}})\">\r\n  <summary>\r\n            Transforms an observable sequence of observable sequences into an observable sequence \r\n            producing values only from the most recent observable sequence.\r\n            Each time a new inner observable sequence is received, unsubscribe from the \r\n            previous inner observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequences.</typeparam>\r\n  <param name=\"sources\">Observable sequence of inner observable sequences.</param>\r\n  <returns>The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"sources\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<System.IObservable<TSource>>",
              "PinAttribute": {
                "Help": "Observable sequence of inner observable sequences.",
                "ImportedHelp": "<param name=\"sources\">Observable sequence of inner observable sequences.</param>"
              },
              "DotNetName": "sources"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.",
              "ImportedHelp": "<returns>The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Switch"
        },
        {
          "NodeAttribute": {
            "Name": "Take",
            "Category": "Reactive.Observable",
            "Help": "Returns a specified number of contiguous elements from the start of an observable sequence.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)\">\r\n  <summary>\r\n            Returns a specified number of contiguous elements from the start of an observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">The sequence to take elements from.</param>\r\n  <param name=\"count\">The number of elements to return.</param>\r\n  <returns>An observable sequence that contains the specified number of elements from the start of the input sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"count\" /> is less than zero.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "The sequence to take elements from.",
                "ImportedHelp": "<param name=\"source\">The sequence to take elements from.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Int32",
              "PinAttribute": {
                "Help": "The number of elements to return.",
                "ImportedHelp": "<param name=\"count\">The number of elements to return.</param>"
              },
              "DotNetName": "count"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence that contains the specified number of elements from the start of the input sequence.",
              "ImportedHelp": "<returns>An observable sequence that contains the specified number of elements from the start of the input sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Take"
        },
        {
          "NodeAttribute": {
            "Name": "Take",
            "Version": "Duration",
            "Category": "Reactive.Observable",
            "Help": "Takes elements for the specified duration from the start of the observable source sequence.\r\nRemarks: Specifying a TimeSpan.Zero value for Duration doesn't guarantee an empty sequence will be returned. This is a side-effect\n            of the asynchrony introduced by the scheduler, where the action that stops forwarding callbacks from the source sequence may not execute\n            immediately, despite the TimeSpan.Zero due time.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.TimeSpan)\">\r\n  <summary>\r\n            Takes elements for the specified duration from the start of the observable source sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to take elements from.</param>\r\n  <param name=\"duration\">Duration for taking elements from the start of the sequence.</param>\r\n  <returns>An observable sequence with the elements taken during the specified duration from the start of the source sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"duration\" /> is less than TimeSpan.Zero.</exception>\r\n  <remarks>\r\n            Specifying a TimeSpan.Zero value for <paramref name=\"duration\" /> doesn't guarantee an empty sequence will be returned. This is a side-effect\r\n            of the asynchrony introduced by the scheduler, where the action that stops forwarding callbacks from the source sequence may not execute\r\n            immediately, despite the TimeSpan.Zero due time.\r\n            </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to take elements from.",
                "ImportedHelp": "<param name=\"source\">Source sequence to take elements from.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Duration for taking elements from the start of the sequence.",
                "ImportedHelp": "<param name=\"duration\">Duration for taking elements from the start of the sequence.</param>"
              },
              "DotNetName": "duration"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence with the elements taken during the specified duration from the start of the source sequence.",
              "ImportedHelp": "<returns>An observable sequence with the elements taken during the specified duration from the start of the source sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Take"
        },
        {
          "NodeAttribute": {
            "Name": "TakeLast",
            "Category": "Reactive.Observable",
            "Help": "Returns a specified number of contiguous elements from the end of an observable sequence.\r\nRemarks: This operator accumulates a buffer with a length enough to store elements Count elements. Upon completion of\n            the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.TakeLast``1(System.IObservable{``0},System.Int32)\">\r\n  <summary>\r\n            Returns a specified number of contiguous elements from the end of an observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence.</param>\r\n  <param name=\"count\">Number of elements to take from the end of the source sequence.</param>\r\n  <returns>An observable sequence containing the specified number of elements from the end of the source sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"count\" /> is less than zero.</exception>\r\n  <remarks>\r\n            This operator accumulates a buffer with a length enough to store elements <paramref name=\"count\" /> elements. Upon completion of\r\n            the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.\r\n            </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence.",
                "ImportedHelp": "<param name=\"source\">Source sequence.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Int32",
              "PinAttribute": {
                "Help": "Number of elements to take from the end of the source sequence.",
                "ImportedHelp": "<param name=\"count\">Number of elements to take from the end of the source sequence.</param>"
              },
              "DotNetName": "count"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence containing the specified number of elements from the end of the source sequence.",
              "ImportedHelp": "<returns>An observable sequence containing the specified number of elements from the end of the source sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "TakeLast"
        },
        {
          "NodeAttribute": {
            "Name": "TakeLast",
            "Version": "Duration",
            "Category": "Reactive.Observable",
            "Help": "Returns elements within the specified duration from the end of the observable source sequence.\r\nRemarks: This operator accumulates a buffer with a length enough to store elements for any Duration window during the lifetime of\n            the source sequence. Upon completion of the source sequence, this buffer is drained on the result sequence. This causes the result elements\n            to be delayed with Duration.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.TakeLast``1(System.IObservable{``0},System.TimeSpan)\">\r\n  <summary>\r\n            Returns elements within the specified duration from the end of the observable source sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to take elements from.</param>\r\n  <param name=\"duration\">Duration for taking elements from the end of the sequence.</param>\r\n  <returns>An observable sequence with the elements taken during the specified duration from the end of the source sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"duration\" /> is less than TimeSpan.Zero.</exception>\r\n  <remarks>\r\n            This operator accumulates a buffer with a length enough to store elements for any <paramref name=\"duration\" /> window during the lifetime of\r\n            the source sequence. Upon completion of the source sequence, this buffer is drained on the result sequence. This causes the result elements\r\n            to be delayed with <paramref name=\"duration\" />.\r\n            </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to take elements from.",
                "ImportedHelp": "<param name=\"source\">Source sequence to take elements from.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Duration for taking elements from the end of the sequence.",
                "ImportedHelp": "<param name=\"duration\">Duration for taking elements from the end of the sequence.</param>"
              },
              "DotNetName": "duration"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence with the elements taken during the specified duration from the end of the source sequence.",
              "ImportedHelp": "<returns>An observable sequence with the elements taken during the specified duration from the end of the source sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "TakeLast"
        },
        {
          "NodeAttribute": {
            "Name": "TakeUntil",
            "Category": "Reactive.Observable",
            "Help": "Returns the elements from the source observable sequence until the other observable sequence produces an element.TSource: The type of the elements in the source sequence.\r\nTOther: The type of the elements in the other sequence that indicates the end of take behavior.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.TakeUntil``2(System.IObservable{``0},System.IObservable{``1})\">\r\n  <summary>\r\n            Returns the elements from the source observable sequence until the other observable sequence produces an element.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TOther\">The type of the elements in the other sequence that indicates the end of take behavior.</typeparam>\r\n  <param name=\"source\">Source sequence to propagate elements for.</param>\r\n  <param name=\"other\">Observable sequence that terminates propagation of elements of the source sequence.</param>\r\n  <returns>An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"other\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to propagate elements for.",
                "ImportedHelp": "<param name=\"source\">Source sequence to propagate elements for.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.IObservable<TOther>",
              "PinAttribute": {
                "Help": "Observable sequence that terminates propagation of elements of the source sequence.",
                "ImportedHelp": "<param name=\"other\">Observable sequence that terminates propagation of elements of the source sequence.</param>"
              },
              "DotNetName": "other"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.",
              "ImportedHelp": "<returns>An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "TakeUntil"
        },
        {
          "NodeAttribute": {
            "Name": "TakeWhile",
            "Category": "Reactive.Observable",
            "Help": "Returns elements from an observable sequence as long as a specified condition is true.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.TakeWhile``1(System.IObservable{``0},System.Func{``0,System.Boolean})\">\r\n  <summary>\r\n            Returns elements from an observable sequence as long as a specified condition is true.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">A sequence to return elements from.</param>\r\n  <param name=\"predicate\">A function to test each element for a condition.</param>\r\n  <returns>An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"predicate\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "A sequence to return elements from.",
                "ImportedHelp": "<param name=\"source\">A sequence to return elements from.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, System.Boolean>",
              "PinAttribute": {
                "Help": "A function to test each element for a condition.",
                "ImportedHelp": "<param name=\"predicate\">A function to test each element for a condition.</param>"
              },
              "DotNetName": "predicate"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.",
              "ImportedHelp": "<returns>An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "TakeWhile"
        },
        {
          "NodeAttribute": {
            "Name": "Then",
            "Category": "Reactive.Observable",
            "Help": "Matches when the observable sequence has an available element and projects the element by invoking the selector function.TSource: The type of the elements in the source sequence.\r\nTResult: The type of the elements in the result sequence, returned by the selector function.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Then``2(System.IObservable{``0},System.Func{``0,``1})\">\r\n  <summary>\r\n            Matches when the observable sequence has an available element and projects the element by invoking the selector function.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence, returned by the selector function.</typeparam>\r\n  <param name=\"source\">Observable sequence to apply the selector on.</param>\r\n  <param name=\"selector\">Selector that will be invoked for elements in the source sequence.</param>\r\n  <returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"selector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Observable sequence to apply the selector on.",
                "ImportedHelp": "<param name=\"source\">Observable sequence to apply the selector on.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, TResult>",
              "PinAttribute": {
                "Help": "Selector that will be invoked for elements in the source sequence.",
                "ImportedHelp": "<param name=\"selector\">Selector that will be invoked for elements in the source sequence.</param>"
              },
              "DotNetName": "selector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Plan<TResult>",
            "PinAttribute": {
              "Help": "Plan that produces the projected results, to be fed (with other plans) to the When operator.",
              "ImportedHelp": "<returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Then"
        },
        {
          "NodeAttribute": {
            "Name": "Throttle",
            "Category": "System.Reactive.Linq",
            "Help": "Ignores elements from an observable sequence which are followed by another element within a specified relative time duration.\r\nRemarks: This operator throttles the source sequence by holding on to each element for the duration specified in Due Time. If another\n            element is produced within this time window, the element is dropped and a new timer is started for the current element, repeating this whole\n            process. For streams that never have gaps larger than or equal to Due Time between elements, the resulting stream won't\n            produce any elements. In order to reduce the volume of a stream whilst guaranteeing the periodic production of elements, consider using the\n            Observable.Sample set of operators.Specifying a TimeSpan.Zero value for Due Time is not recommended but supported, causing throttling timers to be scheduled\n            that are due immediately. However, this doesn't guarantee all elements will be retained in the result sequence. This is a side-effect of the\n            asynchrony introduced by the scheduler, where the action to forward the current element may not execute immediately, despite the TimeSpan.Zero\n            due time. In such cases, the next element may arrive before the scheduler gets a chance to run the throttling action.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Throttle``1(System.IObservable{``0},System.TimeSpan)\">\r\n  <summary>\r\n            Ignores elements from an observable sequence which are followed by another element within a specified relative time duration.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to throttle.</param>\r\n  <param name=\"dueTime\">Throttling duration for each element.</param>\r\n  <returns>The throttled sequence.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"dueTime\" /> is less than TimeSpan.Zero.</exception>\r\n  <remarks>\r\n    <para>\r\n            This operator throttles the source sequence by holding on to each element for the duration specified in <paramref name=\"dueTime\" />. If another\r\n            element is produced within this time window, the element is dropped and a new timer is started for the current element, repeating this whole\r\n            process. For streams that never have gaps larger than or equal to <paramref name=\"dueTime\" /> between elements, the resulting stream won't\r\n            produce any elements. In order to reduce the volume of a stream whilst guaranteeing the periodic production of elements, consider using the\r\n            Observable.Sample set of operators.\r\n            </para>\r\n    <para>\r\n            Specifying a TimeSpan.Zero value for <paramref name=\"dueTime\" /> is not recommended but supported, causing throttling timers to be scheduled\r\n            that are due immediately. However, this doesn't guarantee all elements will be retained in the result sequence. This is a side-effect of the\r\n            asynchrony introduced by the scheduler, where the action to forward the current element may not execute immediately, despite the TimeSpan.Zero\r\n            due time. In such cases, the next element may arrive before the scheduler gets a chance to run the throttling action.\r\n            </para>\r\n  </remarks>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to throttle.",
                "ImportedHelp": "<param name=\"source\">Source sequence to throttle.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Throttling duration for each element.",
                "ImportedHelp": "<param name=\"dueTime\">Throttling duration for each element.</param>"
              },
              "DotNetName": "dueTime"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "The throttled sequence.",
              "ImportedHelp": "<returns>The throttled sequence.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Throttle"
        },
        {
          "NodeAttribute": {
            "Name": "TimeInterval",
            "Category": "Reactive.Observable",
            "Help": "Records the time interval between consecutive elements in an observable sequence.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.TimeInterval``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Records the time interval between consecutive elements in an observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to record time intervals for.</param>\r\n  <returns>An observable sequence with time interval information on elements.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to record time intervals for.",
                "ImportedHelp": "<param name=\"source\">Source sequence to record time intervals for.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Reactive.TimeInterval<TSource>>",
            "PinAttribute": {
              "Help": "An observable sequence with time interval information on elements.",
              "ImportedHelp": "<returns>An observable sequence with time interval information on elements.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "TimeInterval"
        },
        {
          "NodeAttribute": {
            "Name": "Timer",
            "Category": "Reactive.Observable",
            "Help": "Returns an observable sequence that periodically produces a value after the specified initial relative due time has elapsed.",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Timer(System.TimeSpan,System.TimeSpan)\">\r\n  <summary>\r\n            Returns an observable sequence that periodically produces a value after the specified initial relative due time has elapsed.\r\n            </summary>\r\n  <param name=\"dueTime\">Relative time at which to produce the first value. If this value is less than or equal to TimeSpan.Zero, the timer will fire as soon as possible.</param>\r\n  <param name=\"period\">Period to produce subsequent values. If this value is equal to TimeSpan.Zero, the timer will recur as fast as possible.</param>\r\n  <returns>An observable sequence that produces a value after due time has elapsed and then after each period.</returns>\r\n  <exception cref=\"T:System.ArgumentOutOfRangeException\">\r\n    <paramref name=\"period\" /> is less than TimeSpan.Zero.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Relative time at which to produce the first value. If this value is less than or equal to TimeSpan.Zero, the timer will fire as soon as possible.",
                "ImportedHelp": "<param name=\"dueTime\">Relative time at which to produce the first value. If this value is less than or equal to TimeSpan.Zero, the timer will fire as soon as possible.</param>"
              },
              "DotNetName": "dueTime"
            },
            {
              "TypeFullName": "System.TimeSpan",
              "PinAttribute": {
                "Help": "Period to produce subsequent values. If this value is equal to TimeSpan.Zero, the timer will recur as fast as possible.",
                "ImportedHelp": "<param name=\"period\">Period to produce subsequent values. If this value is equal to TimeSpan.Zero, the timer will recur as fast as possible.</param>"
              },
              "DotNetName": "period"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Int64>",
            "PinAttribute": {
              "Help": "An observable sequence that produces a value after due time has elapsed and then after each period.",
              "ImportedHelp": "<returns>An observable sequence that produces a value after due time has elapsed and then after each period.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Timer"
        },
        {
          "NodeAttribute": {
            "Name": "Timestamp",
            "Category": "Reactive.Observable",
            "Help": "Timestamps each element in an observable sequence using the local system clock.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Timestamp``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Timestamps each element in an observable sequence using the local system clock.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">Source sequence to timestamp elements for.</param>\r\n  <returns>An observable sequence with timestamp information on elements.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "Source sequence to timestamp elements for.",
                "ImportedHelp": "<param name=\"source\">Source sequence to timestamp elements for.</param>"
              },
              "DotNetName": "source"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<System.Reactive.Timestamped<TSource>>",
            "PinAttribute": {
              "Help": "An observable sequence with timestamp information on elements.",
              "ImportedHelp": "<returns>An observable sequence with timestamp information on elements.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Timestamp"
        },
        {
          "NodeAttribute": {
            "Name": "Where",
            "Category": "Reactive.Observable",
            "Help": "Filters the elements of an observable sequence based on a predicate.TSource: The type of the elements in the source sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Linq.Observable.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean})\">\r\n  <summary>\r\n            Filters the elements of an observable sequence based on a predicate.\r\n            </summary>\r\n  <typeparam name=\"TSource\">The type of the elements in the source sequence.</typeparam>\r\n  <param name=\"source\">An observable sequence whose elements to filter.</param>\r\n  <param name=\"predicate\">A function to test each source element for a condition.</param>\r\n  <returns>An observable sequence that contains elements from the input sequence that satisfy the condition.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"source\" /> or <paramref name=\"predicate\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource>",
              "PinAttribute": {
                "Help": "An observable sequence whose elements to filter.",
                "ImportedHelp": "<param name=\"source\">An observable sequence whose elements to filter.</param>"
              },
              "DotNetName": "source"
            },
            {
              "TypeFullName": "System.Func<TSource, System.Boolean>",
              "PinAttribute": {
                "Help": "A function to test each source element for a condition.",
                "ImportedHelp": "<param name=\"predicate\">A function to test each source element for a condition.</param>"
              },
              "DotNetName": "predicate"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.IObservable<TSource>",
            "PinAttribute": {
              "Help": "An observable sequence that contains elements from the input sequence that satisfy the condition.",
              "ImportedHelp": "<returns>An observable sequence that contains elements from the input sequence that satisfy the condition.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Where"
        }
      ],
      "DotNetName": "System.Reactive.Linq.Observable"
    },
    {
      "TypeAttribute": {
        "Name": "Pattern",
        "Category": "Reactive.Joins",
        "Help": "Represents a join pattern over one observable sequence.TSource1: The type of the elements in the first source sequence.\r\n",
        "ImportedHelp": "<member name=\"T:System.Reactive.Joins.Pattern`1\">\r\n  <summary>\r\n            Represents a join pattern over one observable sequence.\r\n            </summary>\r\n  <typeparam name=\"TSource1\">The type of the elements in the first source sequence.</typeparam>\r\n</member>"
      },
      "Members": [
        {
          "NodeAttribute": {
            "Name": "Then",
            "Help": "Matches when all observable sequences have an available element and projects the elements by invoking the selector function.TResult: The type of the elements in the result sequence, returned by the selector function.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`1.Then``1(System.Func{`0,``0})\">\r\n  <summary>\r\n            Matches when all observable sequences have an available element and projects the elements by invoking the selector function.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence, returned by the selector function.</typeparam>\r\n  <param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>\r\n  <returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"selector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<TSource1, TResult>",
              "PinAttribute": {
                "Help": "Selector that will be invoked for elements in the source sequences.",
                "ImportedHelp": "<param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>"
              },
              "DotNetName": "selector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Plan<TResult>",
            "PinAttribute": {
              "Help": "Plan that produces the projected results, to be fed (with other plans) to the When operator.",
              "ImportedHelp": "<returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Then"
        }
      ],
      "DotNetName": "System.Reactive.Joins.Pattern`1"
    },
    {
      "TypeAttribute": {
        "Name": "Pattern",
        "Category": "Reactive.Joins",
        "Help": "Represents a join pattern over eight observable sequences.TSource1: The type of the elements in the first source sequence.\r\nTSource2: The type of the elements in the second source sequence.\r\nTSource3: The type of the elements in the third source sequence.\r\nTSource4: The type of the elements in the fourth source sequence.\r\nTSource5: The type of the elements in the fifth source sequence.\r\nTSource6: The type of the elements in the sixth source sequence.\r\nTSource7: The type of the elements in the seventh source sequence.\r\nTSource8: The type of the elements in the eighth source sequence.\r\n",
        "ImportedHelp": "<member name=\"T:System.Reactive.Joins.Pattern`8\">\r\n  <summary>\r\n            Represents a join pattern over eight observable sequences.\r\n            </summary>\r\n  <typeparam name=\"TSource1\">The type of the elements in the first source sequence.</typeparam>\r\n  <typeparam name=\"TSource2\">The type of the elements in the second source sequence.</typeparam>\r\n  <typeparam name=\"TSource3\">The type of the elements in the third source sequence.</typeparam>\r\n  <typeparam name=\"TSource4\">The type of the elements in the fourth source sequence.</typeparam>\r\n  <typeparam name=\"TSource5\">The type of the elements in the fifth source sequence.</typeparam>\r\n  <typeparam name=\"TSource6\">The type of the elements in the sixth source sequence.</typeparam>\r\n  <typeparam name=\"TSource7\">The type of the elements in the seventh source sequence.</typeparam>\r\n  <typeparam name=\"TSource8\">The type of the elements in the eighth source sequence.</typeparam>\r\n</member>"
      },
      "Members": [
        {
          "NodeAttribute": {
            "Name": "And",
            "Help": "Creates a pattern that matches when all nine observable sequences have an available element.TSource9: The type of the elements in the ninth observable sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`8.And``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Creates a pattern that matches when all nine observable sequences have an available element.\r\n            </summary>\r\n  <typeparam name=\"TSource9\">The type of the elements in the ninth observable sequence.</typeparam>\r\n  <param name=\"other\">Observable sequence to match with the eight previous sequences.</param>\r\n  <returns>Pattern object that matches when all observable sequences have an available element.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"other\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource9>",
              "PinAttribute": {
                "Help": "Observable sequence to match with the eight previous sequences.",
                "ImportedHelp": "<param name=\"other\">Observable sequence to match with the eight previous sequences.</param>"
              },
              "DotNetName": "other"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Pattern<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9>",
            "PinAttribute": {
              "Help": "Pattern object that matches when all observable sequences have an available element.",
              "ImportedHelp": "<returns>Pattern object that matches when all observable sequences have an available element.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "And"
        },
        {
          "NodeAttribute": {
            "Name": "Then",
            "Help": "Matches when all observable sequences have an available element and projects the elements by invoking the selector function.TResult: The type of the elements in the result sequence, returned by the selector function.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`8.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,``0})\">\r\n  <summary>\r\n            Matches when all observable sequences have an available element and projects the elements by invoking the selector function.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence, returned by the selector function.</typeparam>\r\n  <param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>\r\n  <returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"selector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TResult>",
              "PinAttribute": {
                "Help": "Selector that will be invoked for elements in the source sequences.",
                "ImportedHelp": "<param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>"
              },
              "DotNetName": "selector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Plan<TResult>",
            "PinAttribute": {
              "Help": "Plan that produces the projected results, to be fed (with other plans) to the When operator.",
              "ImportedHelp": "<returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Then"
        }
      ],
      "DotNetName": "System.Reactive.Joins.Pattern`8"
    },
    {
      "TypeAttribute": {
        "Name": "Pattern",
        "Category": "Reactive.Joins",
        "Help": "Represents a join pattern over seven observable sequences.TSource1: The type of the elements in the first source sequence.\r\nTSource2: The type of the elements in the second source sequence.\r\nTSource3: The type of the elements in the third source sequence.\r\nTSource4: The type of the elements in the fourth source sequence.\r\nTSource5: The type of the elements in the fifth source sequence.\r\nTSource6: The type of the elements in the sixth source sequence.\r\nTSource7: The type of the elements in the seventh source sequence.\r\n",
        "ImportedHelp": "<member name=\"T:System.Reactive.Joins.Pattern`7\">\r\n  <summary>\r\n            Represents a join pattern over seven observable sequences.\r\n            </summary>\r\n  <typeparam name=\"TSource1\">The type of the elements in the first source sequence.</typeparam>\r\n  <typeparam name=\"TSource2\">The type of the elements in the second source sequence.</typeparam>\r\n  <typeparam name=\"TSource3\">The type of the elements in the third source sequence.</typeparam>\r\n  <typeparam name=\"TSource4\">The type of the elements in the fourth source sequence.</typeparam>\r\n  <typeparam name=\"TSource5\">The type of the elements in the fifth source sequence.</typeparam>\r\n  <typeparam name=\"TSource6\">The type of the elements in the sixth source sequence.</typeparam>\r\n  <typeparam name=\"TSource7\">The type of the elements in the seventh source sequence.</typeparam>\r\n</member>"
      },
      "Members": [
        {
          "NodeAttribute": {
            "Name": "And",
            "Help": "Creates a pattern that matches when all eight observable sequences have an available element.TSource8: The type of the elements in the eighth observable sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`7.And``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Creates a pattern that matches when all eight observable sequences have an available element.\r\n            </summary>\r\n  <typeparam name=\"TSource8\">The type of the elements in the eighth observable sequence.</typeparam>\r\n  <param name=\"other\">Observable sequence to match with the seven previous sequences.</param>\r\n  <returns>Pattern object that matches when all observable sequences have an available element.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"other\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource8>",
              "PinAttribute": {
                "Help": "Observable sequence to match with the seven previous sequences.",
                "ImportedHelp": "<param name=\"other\">Observable sequence to match with the seven previous sequences.</param>"
              },
              "DotNetName": "other"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Pattern<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8>",
            "PinAttribute": {
              "Help": "Pattern object that matches when all observable sequences have an available element.",
              "ImportedHelp": "<returns>Pattern object that matches when all observable sequences have an available element.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "And"
        },
        {
          "NodeAttribute": {
            "Name": "Then",
            "Help": "Matches when all observable sequences have an available element and projects the elements by invoking the selector function.TResult: The type of the elements in the result sequence, returned by the selector function.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`7.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,``0})\">\r\n  <summary>\r\n            Matches when all observable sequences have an available element and projects the elements by invoking the selector function.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence, returned by the selector function.</typeparam>\r\n  <param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>\r\n  <returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"selector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TResult>",
              "PinAttribute": {
                "Help": "Selector that will be invoked for elements in the source sequences.",
                "ImportedHelp": "<param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>"
              },
              "DotNetName": "selector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Plan<TResult>",
            "PinAttribute": {
              "Help": "Plan that produces the projected results, to be fed (with other plans) to the When operator.",
              "ImportedHelp": "<returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Then"
        }
      ],
      "DotNetName": "System.Reactive.Joins.Pattern`7"
    },
    {
      "TypeAttribute": {
        "Name": "Pattern",
        "Category": "Reactive.Joins",
        "Help": "Represents a join pattern over six observable sequences.TSource1: The type of the elements in the first source sequence.\r\nTSource2: The type of the elements in the second source sequence.\r\nTSource3: The type of the elements in the third source sequence.\r\nTSource4: The type of the elements in the fourth source sequence.\r\nTSource5: The type of the elements in the fifth source sequence.\r\nTSource6: The type of the elements in the sixth source sequence.\r\n",
        "ImportedHelp": "<member name=\"T:System.Reactive.Joins.Pattern`6\">\r\n  <summary>\r\n            Represents a join pattern over six observable sequences.\r\n            </summary>\r\n  <typeparam name=\"TSource1\">The type of the elements in the first source sequence.</typeparam>\r\n  <typeparam name=\"TSource2\">The type of the elements in the second source sequence.</typeparam>\r\n  <typeparam name=\"TSource3\">The type of the elements in the third source sequence.</typeparam>\r\n  <typeparam name=\"TSource4\">The type of the elements in the fourth source sequence.</typeparam>\r\n  <typeparam name=\"TSource5\">The type of the elements in the fifth source sequence.</typeparam>\r\n  <typeparam name=\"TSource6\">The type of the elements in the sixth source sequence.</typeparam>\r\n</member>"
      },
      "Members": [
        {
          "NodeAttribute": {
            "Name": "And",
            "Help": "Creates a pattern that matches when all seven observable sequences have an available element.TSource7: The type of the elements in the seventh observable sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`6.And``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Creates a pattern that matches when all seven observable sequences have an available element.\r\n            </summary>\r\n  <typeparam name=\"TSource7\">The type of the elements in the seventh observable sequence.</typeparam>\r\n  <param name=\"other\">Observable sequence to match with the six previous sequences.</param>\r\n  <returns>Pattern object that matches when all observable sequences have an available element.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"other\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource7>",
              "PinAttribute": {
                "Help": "Observable sequence to match with the six previous sequences.",
                "ImportedHelp": "<param name=\"other\">Observable sequence to match with the six previous sequences.</param>"
              },
              "DotNetName": "other"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Pattern<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7>",
            "PinAttribute": {
              "Help": "Pattern object that matches when all observable sequences have an available element.",
              "ImportedHelp": "<returns>Pattern object that matches when all observable sequences have an available element.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "And"
        },
        {
          "NodeAttribute": {
            "Name": "Then",
            "Help": "Matches when all observable sequences have an available element and projects the elements by invoking the selector function.TResult: The type of the elements in the result sequence, returned by the selector function.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`6.Then``1(System.Func{`0,`1,`2,`3,`4,`5,``0})\">\r\n  <summary>\r\n            Matches when all observable sequences have an available element and projects the elements by invoking the selector function.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence, returned by the selector function.</typeparam>\r\n  <param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>\r\n  <returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"selector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TResult>",
              "PinAttribute": {
                "Help": "Selector that will be invoked for elements in the source sequences.",
                "ImportedHelp": "<param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>"
              },
              "DotNetName": "selector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Plan<TResult>",
            "PinAttribute": {
              "Help": "Plan that produces the projected results, to be fed (with other plans) to the When operator.",
              "ImportedHelp": "<returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Then"
        }
      ],
      "DotNetName": "System.Reactive.Joins.Pattern`6"
    },
    {
      "TypeAttribute": {
        "Name": "Pattern",
        "Category": "Reactive.Joins",
        "Help": "Represents a join pattern over five observable sequences.TSource1: The type of the elements in the first source sequence.\r\nTSource2: The type of the elements in the second source sequence.\r\nTSource3: The type of the elements in the third source sequence.\r\nTSource4: The type of the elements in the fourth source sequence.\r\nTSource5: The type of the elements in the fifth source sequence.\r\n",
        "ImportedHelp": "<member name=\"T:System.Reactive.Joins.Pattern`5\">\r\n  <summary>\r\n            Represents a join pattern over five observable sequences.\r\n            </summary>\r\n  <typeparam name=\"TSource1\">The type of the elements in the first source sequence.</typeparam>\r\n  <typeparam name=\"TSource2\">The type of the elements in the second source sequence.</typeparam>\r\n  <typeparam name=\"TSource3\">The type of the elements in the third source sequence.</typeparam>\r\n  <typeparam name=\"TSource4\">The type of the elements in the fourth source sequence.</typeparam>\r\n  <typeparam name=\"TSource5\">The type of the elements in the fifth source sequence.</typeparam>\r\n</member>"
      },
      "Members": [
        {
          "NodeAttribute": {
            "Name": "And",
            "Help": "Creates a pattern that matches when all six observable sequences have an available element.TSource6: The type of the elements in the sixth observable sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`5.And``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Creates a pattern that matches when all six observable sequences have an available element.\r\n            </summary>\r\n  <typeparam name=\"TSource6\">The type of the elements in the sixth observable sequence.</typeparam>\r\n  <param name=\"other\">Observable sequence to match with the five previous sequences.</param>\r\n  <returns>Pattern object that matches when all observable sequences have an available element.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"other\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource6>",
              "PinAttribute": {
                "Help": "Observable sequence to match with the five previous sequences.",
                "ImportedHelp": "<param name=\"other\">Observable sequence to match with the five previous sequences.</param>"
              },
              "DotNetName": "other"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Pattern<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6>",
            "PinAttribute": {
              "Help": "Pattern object that matches when all observable sequences have an available element.",
              "ImportedHelp": "<returns>Pattern object that matches when all observable sequences have an available element.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "And"
        },
        {
          "NodeAttribute": {
            "Name": "Then",
            "Help": "Matches when all observable sequences have an available element and projects the elements by invoking the selector function.TResult: The type of the elements in the result sequence, returned by the selector function.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`5.Then``1(System.Func{`0,`1,`2,`3,`4,``0})\">\r\n  <summary>\r\n            Matches when all observable sequences have an available element and projects the elements by invoking the selector function.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence, returned by the selector function.</typeparam>\r\n  <param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>\r\n  <returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"selector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<TSource1, TSource2, TSource3, TSource4, TSource5, TResult>",
              "PinAttribute": {
                "Help": "Selector that will be invoked for elements in the source sequences.",
                "ImportedHelp": "<param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>"
              },
              "DotNetName": "selector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Plan<TResult>",
            "PinAttribute": {
              "Help": "Plan that produces the projected results, to be fed (with other plans) to the When operator.",
              "ImportedHelp": "<returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Then"
        }
      ],
      "DotNetName": "System.Reactive.Joins.Pattern`5"
    },
    {
      "TypeAttribute": {
        "Name": "Pattern",
        "Category": "Reactive.Joins",
        "Help": "Represents a join pattern over four observable sequences.TSource1: The type of the elements in the first source sequence.\r\nTSource2: The type of the elements in the second source sequence.\r\nTSource3: The type of the elements in the third source sequence.\r\nTSource4: The type of the elements in the fourth source sequence.\r\n",
        "ImportedHelp": "<member name=\"T:System.Reactive.Joins.Pattern`4\">\r\n  <summary>\r\n            Represents a join pattern over four observable sequences.\r\n            </summary>\r\n  <typeparam name=\"TSource1\">The type of the elements in the first source sequence.</typeparam>\r\n  <typeparam name=\"TSource2\">The type of the elements in the second source sequence.</typeparam>\r\n  <typeparam name=\"TSource3\">The type of the elements in the third source sequence.</typeparam>\r\n  <typeparam name=\"TSource4\">The type of the elements in the fourth source sequence.</typeparam>\r\n</member>"
      },
      "Members": [
        {
          "NodeAttribute": {
            "Name": "And",
            "Help": "Creates a pattern that matches when all five observable sequences have an available element.TSource5: The type of the elements in the fifth observable sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`4.And``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Creates a pattern that matches when all five observable sequences have an available element.\r\n            </summary>\r\n  <typeparam name=\"TSource5\">The type of the elements in the fifth observable sequence.</typeparam>\r\n  <param name=\"other\">Observable sequence to match with the four previous sequences.</param>\r\n  <returns>Pattern object that matches when all observable sequences have an available element.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"other\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource5>",
              "PinAttribute": {
                "Help": "Observable sequence to match with the four previous sequences.",
                "ImportedHelp": "<param name=\"other\">Observable sequence to match with the four previous sequences.</param>"
              },
              "DotNetName": "other"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Pattern<TSource1, TSource2, TSource3, TSource4, TSource5>",
            "PinAttribute": {
              "Help": "Pattern object that matches when all observable sequences have an available element.",
              "ImportedHelp": "<returns>Pattern object that matches when all observable sequences have an available element.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "And"
        },
        {
          "NodeAttribute": {
            "Name": "Then",
            "Help": "Matches when all observable sequences have an available element and projects the elements by invoking the selector function.TResult: The type of the elements in the result sequence, returned by the selector function.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`4.Then``1(System.Func{`0,`1,`2,`3,``0})\">\r\n  <summary>\r\n            Matches when all observable sequences have an available element and projects the elements by invoking the selector function.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence, returned by the selector function.</typeparam>\r\n  <param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>\r\n  <returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"selector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<TSource1, TSource2, TSource3, TSource4, TResult>",
              "PinAttribute": {
                "Help": "Selector that will be invoked for elements in the source sequences.",
                "ImportedHelp": "<param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>"
              },
              "DotNetName": "selector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Plan<TResult>",
            "PinAttribute": {
              "Help": "Plan that produces the projected results, to be fed (with other plans) to the When operator.",
              "ImportedHelp": "<returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Then"
        }
      ],
      "DotNetName": "System.Reactive.Joins.Pattern`4"
    },
    {
      "TypeAttribute": {
        "Name": "Pattern",
        "Category": "Reactive.Joins",
        "Help": "Represents a join pattern over three observable sequences.TSource1: The type of the elements in the first source sequence.\r\nTSource2: The type of the elements in the second source sequence.\r\nTSource3: The type of the elements in the third source sequence.\r\n",
        "ImportedHelp": "<member name=\"T:System.Reactive.Joins.Pattern`3\">\r\n  <summary>\r\n            Represents a join pattern over three observable sequences.\r\n            </summary>\r\n  <typeparam name=\"TSource1\">The type of the elements in the first source sequence.</typeparam>\r\n  <typeparam name=\"TSource2\">The type of the elements in the second source sequence.</typeparam>\r\n  <typeparam name=\"TSource3\">The type of the elements in the third source sequence.</typeparam>\r\n</member>"
      },
      "Members": [
        {
          "NodeAttribute": {
            "Name": "And",
            "Help": "Creates a pattern that matches when all four observable sequences have an available element.TSource4: The type of the elements in the fourth observable sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`3.And``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Creates a pattern that matches when all four observable sequences have an available element.\r\n            </summary>\r\n  <typeparam name=\"TSource4\">The type of the elements in the fourth observable sequence.</typeparam>\r\n  <param name=\"other\">Observable sequence to match with the three previous sequences.</param>\r\n  <returns>Pattern object that matches when all observable sequences have an available element.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"other\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource4>",
              "PinAttribute": {
                "Help": "Observable sequence to match with the three previous sequences.",
                "ImportedHelp": "<param name=\"other\">Observable sequence to match with the three previous sequences.</param>"
              },
              "DotNetName": "other"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Pattern<TSource1, TSource2, TSource3, TSource4>",
            "PinAttribute": {
              "Help": "Pattern object that matches when all observable sequences have an available element.",
              "ImportedHelp": "<returns>Pattern object that matches when all observable sequences have an available element.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "And"
        },
        {
          "NodeAttribute": {
            "Name": "Then",
            "Help": "Matches when all observable sequences have an available element and projects the elements by invoking the selector function.TResult: The type of the elements in the result sequence, returned by the selector function.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`3.Then``1(System.Func{`0,`1,`2,``0})\">\r\n  <summary>\r\n            Matches when all observable sequences have an available element and projects the elements by invoking the selector function.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence, returned by the selector function.</typeparam>\r\n  <param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>\r\n  <returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"selector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<TSource1, TSource2, TSource3, TResult>",
              "PinAttribute": {
                "Help": "Selector that will be invoked for elements in the source sequences.",
                "ImportedHelp": "<param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>"
              },
              "DotNetName": "selector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Plan<TResult>",
            "PinAttribute": {
              "Help": "Plan that produces the projected results, to be fed (with other plans) to the When operator.",
              "ImportedHelp": "<returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Then"
        }
      ],
      "DotNetName": "System.Reactive.Joins.Pattern`3"
    },
    {
      "TypeAttribute": {
        "Name": "Pattern",
        "Category": "Reactive.Joins",
        "Help": "Represents a join pattern over two observable sequences.TSource1: The type of the elements in the first source sequence.\r\nTSource2: The type of the elements in the second source sequence.\r\n",
        "ImportedHelp": "<member name=\"T:System.Reactive.Joins.Pattern`2\">\r\n  <summary>\r\n            Represents a join pattern over two observable sequences.\r\n            </summary>\r\n  <typeparam name=\"TSource1\">The type of the elements in the first source sequence.</typeparam>\r\n  <typeparam name=\"TSource2\">The type of the elements in the second source sequence.</typeparam>\r\n</member>"
      },
      "Members": [
        {
          "NodeAttribute": {
            "Name": "And",
            "Help": "Creates a pattern that matches when all three observable sequences have an available element.TSource3: The type of the elements in the third observable sequence.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`2.And``1(System.IObservable{``0})\">\r\n  <summary>\r\n            Creates a pattern that matches when all three observable sequences have an available element.\r\n            </summary>\r\n  <typeparam name=\"TSource3\">The type of the elements in the third observable sequence.</typeparam>\r\n  <param name=\"other\">Observable sequence to match with the two previous sequences.</param>\r\n  <returns>Pattern object that matches when all observable sequences have an available element.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"other\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.IObservable<TSource3>",
              "PinAttribute": {
                "Help": "Observable sequence to match with the two previous sequences.",
                "ImportedHelp": "<param name=\"other\">Observable sequence to match with the two previous sequences.</param>"
              },
              "DotNetName": "other"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Pattern<TSource1, TSource2, TSource3>",
            "PinAttribute": {
              "Help": "Pattern object that matches when all observable sequences have an available element.",
              "ImportedHelp": "<returns>Pattern object that matches when all observable sequences have an available element.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "And"
        },
        {
          "NodeAttribute": {
            "Name": "Then",
            "Help": "Matches when all observable sequences have an available element and projects the elements by invoking the selector function.TResult: The type of the elements in the result sequence, returned by the selector function.\r\n",
            "ImportedHelp": "<member name=\"M:System.Reactive.Joins.Pattern`2.Then``1(System.Func{`0,`1,``0})\">\r\n  <summary>\r\n            Matches when all observable sequences have an available element and projects the elements by invoking the selector function.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the elements in the result sequence, returned by the selector function.</typeparam>\r\n  <param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>\r\n  <returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>\r\n  <exception cref=\"T:System.ArgumentNullException\">\r\n    <paramref name=\"selector\" /> is null.</exception>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Func<TSource1, TSource2, TResult>",
              "PinAttribute": {
                "Help": "Selector that will be invoked for elements in the source sequences.",
                "ImportedHelp": "<param name=\"selector\">Selector that will be invoked for elements in the source sequences.</param>"
              },
              "DotNetName": "selector"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Reactive.Joins.Plan<TResult>",
            "PinAttribute": {
              "Help": "Plan that produces the projected results, to be fed (with other plans) to the When operator.",
              "ImportedHelp": "<returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "Then"
        }
      ],
      "DotNetName": "System.Reactive.Joins.Pattern`2"
    },
    {
      "TypeAttribute": {
        "Name": "Plan",
        "Category": "Reactive.Joins",
        "Help": "Represents an execution plan for join patterns.TResult: The type of the results produced by the plan.\r\n",
        "ImportedHelp": "<member name=\"T:System.Reactive.Joins.Plan`1\">\r\n  <summary>\r\n            Represents an execution plan for join patterns.\r\n            </summary>\r\n  <typeparam name=\"TResult\">The type of the results produced by the plan.</typeparam>\r\n</member>"
      },
      "Members": [],
      "DotNetName": "System.Reactive.Joins.Plan`1"
    },
    {
      "TypeAttribute": {
        "Name": "TimeInterval",
        "Category": "Reactive",
        "Help": "Represents a value associated with time interval information.\n            The time interval can represent the time it took to produce the value, the interval relative to a previous value, the value's delivery time relative to a base, etc.T: The type of the value being annotated with time interval information.\r\n",
        "ImportedHelp": "<member name=\"T:System.Reactive.TimeInterval`1\">\r\n  <summary>\r\n            Represents a value associated with time interval information.\r\n            The time interval can represent the time it took to produce the value, the interval relative to a previous value, the value's delivery time relative to a base, etc.\r\n            </summary>\r\n  <typeparam name=\"T\">The type of the value being annotated with time interval information.</typeparam>\r\n</member>",
        "IsImmutable": true
      },
      "Members": [
        {
          "NodeAttribute": {
            "Name": "!=",
            "Help": "Determines whether the two specified TimeInterval<T> values don't have the same Value and Interval.",
            "ImportedHelp": "<member name=\"M:System.Reactive.TimeInterval`1.op_Inequality(System.Reactive.TimeInterval{`0},System.Reactive.TimeInterval{`0})\">\r\n  <summary>\r\n            Determines whether the two specified TimeInterval&lt;T&gt; values don't have the same Value and Interval.\r\n            </summary>\r\n  <param name=\"first\">The first TimeInterval&lt;T&gt; value to compare.</param>\r\n  <param name=\"second\">The second TimeInterval&lt;T&gt; value to compare.</param>\r\n  <returns>true if the first TimeInterval&lt;T&gt; value has a different Value or Interval as the second TimeInterval&lt;T&gt; value; otherwise, false.</returns>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Reactive.TimeInterval<T>",
              "PinAttribute": {
                "Help": "The first TimeInterval<T> value to compare.",
                "ImportedHelp": "<param name=\"first\">The first TimeInterval&lt;T&gt; value to compare.</param>"
              },
              "DotNetName": "first"
            },
            {
              "TypeFullName": "System.Reactive.TimeInterval<T>",
              "PinAttribute": {
                "Help": "The second TimeInterval<T> value to compare.",
                "ImportedHelp": "<param name=\"second\">The second TimeInterval&lt;T&gt; value to compare.</param>"
              },
              "DotNetName": "second"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Boolean",
            "PinAttribute": {
              "Help": "true if the first TimeInterval<T> value has a different Value or Interval as the second TimeInterval<T> value; otherwise, false.",
              "ImportedHelp": "<returns>true if the first TimeInterval&lt;T&gt; value has a different Value or Interval as the second TimeInterval&lt;T&gt; value; otherwise, false.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "op_Inequality"
        },
        {
          "NodeAttribute": {
            "Name": "=",
            "Help": "Determines whether the two specified TimeInterval<T> values have the same Value and Interval.",
            "ImportedHelp": "<member name=\"M:System.Reactive.TimeInterval`1.op_Equality(System.Reactive.TimeInterval{`0},System.Reactive.TimeInterval{`0})\">\r\n  <summary>\r\n            Determines whether the two specified TimeInterval&lt;T&gt; values have the same Value and Interval.\r\n            </summary>\r\n  <param name=\"first\">The first TimeInterval&lt;T&gt; value to compare.</param>\r\n  <param name=\"second\">The second TimeInterval&lt;T&gt; value to compare.</param>\r\n  <returns>true if the first TimeInterval&lt;T&gt; value has the same Value and Interval as the second TimeInterval&lt;T&gt; value; otherwise, false.</returns>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Reactive.TimeInterval<T>",
              "PinAttribute": {
                "Help": "The first TimeInterval<T> value to compare.",
                "ImportedHelp": "<param name=\"first\">The first TimeInterval&lt;T&gt; value to compare.</param>"
              },
              "DotNetName": "first"
            },
            {
              "TypeFullName": "System.Reactive.TimeInterval<T>",
              "PinAttribute": {
                "Help": "The second TimeInterval<T> value to compare.",
                "ImportedHelp": "<param name=\"second\">The second TimeInterval&lt;T&gt; value to compare.</param>"
              },
              "DotNetName": "second"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Boolean",
            "PinAttribute": {
              "Help": "true if the first TimeInterval<T> value has the same Value and Interval as the second TimeInterval<T> value; otherwise, false.",
              "ImportedHelp": "<returns>true if the first TimeInterval&lt;T&gt; value has the same Value and Interval as the second TimeInterval&lt;T&gt; value; otherwise, false.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "op_Equality"
        },
        {
          "NodeAttribute": {
            "Name": "Interval",
            "ShowCategory": true,
            "Help": "Gets the interval.",
            "ImportedHelp": "<member name=\"P:System.Reactive.TimeInterval`1.Interval\">\r\n  <summary>\r\n            Gets the interval.\r\n            </summary>\r\n</member>"
          },
          "DotNetName": "Interval"
        },
        {
          "NodeAttribute": {
            "Name": "Value",
            "ShowCategory": true,
            "Help": "Gets the value.",
            "ImportedHelp": "<member name=\"P:System.Reactive.TimeInterval`1.Value\">\r\n  <summary>\r\n            Gets the value.\r\n            </summary>\r\n</member>"
          },
          "DotNetName": "Value"
        }
      ],
      "DotNetName": "System.Reactive.TimeInterval`1"
    },
    {
      "TypeAttribute": {
        "Name": "Timestamped",
        "Category": "Reactive",
        "Help": "Represents value with a timestamp on it.\n            The timestamp typically represents the time the value was received, using an IScheduler's clock to obtain the current time.T: The type of the value being timestamped.\r\n",
        "ImportedHelp": "<member name=\"T:System.Reactive.Timestamped`1\">\r\n  <summary>\r\n            Represents value with a timestamp on it.\r\n            The timestamp typically represents the time the value was received, using an IScheduler's clock to obtain the current time.\r\n            </summary>\r\n  <typeparam name=\"T\">The type of the value being timestamped.</typeparam>\r\n</member>",
        "IsImmutable": true
      },
      "Members": [
        {
          "NodeAttribute": {
            "Name": "!=",
            "Help": "Determines whether the two specified Timestamped<T> values don't have the same Value and Timestamp.",
            "ImportedHelp": "<member name=\"M:System.Reactive.Timestamped`1.op_Inequality(System.Reactive.Timestamped{`0},System.Reactive.Timestamped{`0})\">\r\n  <summary>\r\n            Determines whether the two specified Timestamped&lt;T&gt; values don't have the same Value and Timestamp.\r\n            </summary>\r\n  <param name=\"first\">The first Timestamped&lt;T&gt; value to compare.</param>\r\n  <param name=\"second\">The second Timestamped&lt;T&gt; value to compare.</param>\r\n  <returns>true if the first Timestamped&lt;T&gt; value has a different Value or Timestamp as the second Timestamped&lt;T&gt; value; otherwise, false.</returns>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Reactive.Timestamped<T>",
              "PinAttribute": {
                "Help": "The first Timestamped<T> value to compare.",
                "ImportedHelp": "<param name=\"first\">The first Timestamped&lt;T&gt; value to compare.</param>"
              },
              "DotNetName": "first"
            },
            {
              "TypeFullName": "System.Reactive.Timestamped<T>",
              "PinAttribute": {
                "Help": "The second Timestamped<T> value to compare.",
                "ImportedHelp": "<param name=\"second\">The second Timestamped&lt;T&gt; value to compare.</param>"
              },
              "DotNetName": "second"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Boolean",
            "PinAttribute": {
              "Help": "true if the first Timestamped<T> value has a different Value or Timestamp as the second Timestamped<T> value; otherwise, false.",
              "ImportedHelp": "<returns>true if the first Timestamped&lt;T&gt; value has a different Value or Timestamp as the second Timestamped&lt;T&gt; value; otherwise, false.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "op_Inequality"
        },
        {
          "NodeAttribute": {
            "Name": "=",
            "Help": "Determines whether the two specified Timestamped<T> values have the same Value and Timestamp.",
            "ImportedHelp": "<member name=\"M:System.Reactive.Timestamped`1.op_Equality(System.Reactive.Timestamped{`0},System.Reactive.Timestamped{`0})\">\r\n  <summary>\r\n            Determines whether the two specified Timestamped&lt;T&gt; values have the same Value and Timestamp.\r\n            </summary>\r\n  <param name=\"first\">The first Timestamped&lt;T&gt; value to compare.</param>\r\n  <param name=\"second\">The second Timestamped&lt;T&gt; value to compare.</param>\r\n  <returns>true if the first Timestamped&lt;T&gt; value has the same Value and Timestamp as the second Timestamped&lt;T&gt; value; otherwise, false.</returns>\r\n</member>"
          },
          "Parameters": [
            {
              "TypeFullName": "System.Reactive.Timestamped<T>",
              "PinAttribute": {
                "Help": "The first Timestamped<T> value to compare.",
                "ImportedHelp": "<param name=\"first\">The first Timestamped&lt;T&gt; value to compare.</param>"
              },
              "DotNetName": "first"
            },
            {
              "TypeFullName": "System.Reactive.Timestamped<T>",
              "PinAttribute": {
                "Help": "The second Timestamped<T> value to compare.",
                "ImportedHelp": "<param name=\"second\">The second Timestamped&lt;T&gt; value to compare.</param>"
              },
              "DotNetName": "second"
            }
          ],
          "ReturnValue": {
            "TypeFullName": "System.Boolean",
            "PinAttribute": {
              "Help": "true if the first Timestamped<T> value has the same Value and Timestamp as the second Timestamped<T> value; otherwise, false.",
              "ImportedHelp": "<returns>true if the first Timestamped&lt;T&gt; value has the same Value and Timestamp as the second Timestamped&lt;T&gt; value; otherwise, false.</returns>"
            },
            "PinDirection": 1,
            "DotNetName": "return"
          },
          "DotNetName": "op_Equality"
        },
        {
          "NodeAttribute": {
            "Name": "Timestamp",
            "ShowCategory": true,
            "Help": "Gets the timestamp.",
            "ImportedHelp": "<member name=\"P:System.Reactive.Timestamped`1.Timestamp\">\r\n  <summary>\r\n            Gets the timestamp.\r\n            </summary>\r\n</member>"
          },
          "DotNetName": "Timestamp"
        },
        {
          "NodeAttribute": {
            "Name": "Value",
            "ShowCategory": true,
            "Help": "Gets the value.",
            "ImportedHelp": "<member name=\"P:System.Reactive.Timestamped`1.Value\">\r\n  <summary>\r\n            Gets the value.\r\n            </summary>\r\n</member>"
          },
          "DotNetName": "Value"
        }
      ],
      "DotNetName": "System.Reactive.Timestamped`1"
    }
  ],
  "DotNetName": "System.Reactive.Linq, Version=2.2.5.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
}